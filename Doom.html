<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retro Arena — Debug Build (zbuf fixed)</title>
<style>
  html,body{margin:0;height:100%;background:#0a0c12;color:#eee;font-family:system-ui,Arial}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:8px}
  canvas{width:100vw;max-width:1000px;height:60vh;background:#000;touch-action:none;cursor:crosshair}
  .hud{max-width:1000px;width:100%;display:flex;flex-wrap:wrap;gap:10px;align-items:center;font-size:14px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{padding:.5rem .8rem;border:1px solid #666;background:#1f2330;color:#eee;border-radius:8px;cursor:pointer}
  .spacer{flex:1}
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,.66);display:none;align-items:center;justify-content:center;padding:16px;z-index:30}
  .panel{background:#141824;border:1px solid #41465a;border-radius:12px;padding:16px;max-width:980px;width:95%}
  .err{position:fixed;left:8px;right:8px;top:8px;z-index:40;background:#3b1114;border:1px solid #ff6b6b;border-radius:10px;padding:10px;display:none;white-space:pre-wrap}
  .small{opacity:.85;font-size:13px}
  .kbd{display:inline-block;border:1px solid #5b637d;background:#20273a;border-radius:6px;padding:0 .4rem;margin:0 .1rem}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1000" height="600" aria-label="Arena view"></canvas>
  <div class="hud">
    <div class="row">
      <button id="startBtn" class="btn">Start Game</button>
      <button id="pauseBtn" class="btn">Pause</button>
      <button id="fsBtn" class="btn">Fullscreen</button>
      <button id="lockBtn" class="btn">Mouse Look</button>
    </div>
    <div class="spacer"></div>
    <div class="small">If you see a shifting gradient, rendering works. If the red box appears, copy the message to me.</div>
  </div>
</div>

<div id="pauseOverlay" class="overlay">
  <div class="panel">
    <h2>Paused</h2>
    <p><span class="kbd">WASD</span> move, mouse/←→ look, click to fire, <span class="kbd">Space</span> jump, <span class="kbd">R</span> reload, <span class="kbd">Esc</span> pause.</p>
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px">
      <button id="resumeBtn" class="btn">Resume</button>
      <button id="restartBtn" class="btn">Restart Round</button>
      <button id="quitBtn" class="btn">Quit to Title</button>
    </div>
  </div>
</div>

<div id="errbox" class="err"></div>

<script>
/* Error overlay */
(function(){
  const errbox = document.getElementById('errbox');
  function show(msg){
    errbox.style.display='block';
    errbox.textContent = 'ERROR:\n' + msg;
    console.error(msg);
  }
  addEventListener('error', e=>{
    show((e.message||'Unknown error') +
         (e.filename?('\n'+e.filename+':'+e.lineno+':'+e.colno):'') +
         (e.error&&e.error.stack?('\n'+e.error.stack):''));
  });
  addEventListener('unhandledrejection', e=>{
    show('Unhandled Promise Rejection:\n' + (e.reason&&e.reason.stack?e.reason.stack:JSON.stringify(e.reason)));
  });
})();

/* Safe init */
(function(){ try { main(); } catch(e){ const b=document.getElementById('errbox'); b.style.display='block'; b.textContent='INIT CRASH:\n'+(e.stack||e.message||e); console.error(e);} })();

function main(){
  const canvas = req('#game');
  const ctx = canvas.getContext('2d');

  // declare BEFORE fitCanvas uses it (fix)
  let zbuf;

  let W = canvas.width, H = canvas.height;

  window.requestAnimationFrame = window.requestAnimationFrame || (cb=>setTimeout(()=>cb(performance.now()),16));

  function fitCanvas(){
    const dpr=Math.min(2,window.devicePixelRatio||1);
    const cssW=Math.min(window.innerWidth,1000);
    const cssH=Math.floor(cssW*0.6);
    canvas.style.width=cssW+'px';
    canvas.style.height=cssH+'px';
    canvas.width=Math.floor(cssW*dpr);
    canvas.height=Math.floor(cssH*dpr);
    W=canvas.width; H=canvas.height;
    zbuf = new Float32Array(W); // safe now
  }
  fitCanvas();
  addEventListener('resize', fitCanvas);

  // idle gradient so you see rendering
  let t0 = performance.now(), running=false;
  function hsv(h,s,v){
    s=Math.max(0,Math.min(1,s)); v=Math.max(0,Math.min(1,v));
    h/=60; const i=Math.floor(h), f=h-i;
    const p=v*(1-s), q=v*(1-s*f), t=v*(1-s*(1-f));
    let r,g,b;
    switch(i%6){case 0:r=v;g=t;b=p;break;case 1:r=q;g=v;b=p;break;case 2:r=p;g=v;b=t;break;case 3:r=p;g=q;b=v;break;case 4:r=t;g=p;b=v;break;default:r=v;g=p;b=q;}
    const to255=x=>('0'+(Math.round(x*255)).toString(16)).slice(-2);
    return '#'+to255(r)+to255(g)+to255(b);
  }
  function drawIdle(ts){
    if(running) return;
    const t=(ts-t0)/1000;
    const g=ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,hsv(t*20%360,0.4,0.5));
    g.addColorStop(1,hsv((t*20+120)%360,0.6,0.3));
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#fff'; ctx.font='bold 20px system-ui,Arial';
    ctx.fillText('Idle renderer OK — press Start Game', 16, 16);
    requestAnimationFrame(drawIdle);
  }
  requestAnimationFrame(drawIdle);

  // tiny raycaster demo once started
  const MAP_W=28, MAP_H=24;
  const map=new Array(MAP_W*MAP_H).fill(0);
  const idx=(x,y)=>y*MAP_W+x;
  for(let x=0;x<MAP_W;x++){ map[idx(x,0)]=1; map[idx(x,MAP_H-1)]=1; }
  for(let y=0;y<MAP_H;y++){ map[idx(0,y)]=1; map[idx(MAP_W-1,y)]=1; }
  const WALL_COL={1:'#7bd3ff'};
  const tile=(x,y)=>(x<0||y<0||x>=MAP_W||y>=MAP_H)?1:map[(y|0)*MAP_W+(x|0)];

  function castRay(ax,ay,ang,max=60){
    const sin=Math.sin(ang), cos=Math.cos(ang);
    let dist=0, hit=false, side=0, hitTile=0;
    let mapX=Math.floor(ax), mapY=Math.floor(ay);
    const dX=Math.abs(1/(cos||1e-6)), dY=Math.abs(1/(sin||1e-6));
    let stepX=(cos<0)?-1:1, stepY=(sin<0)?-1:1;
    let sX=(cos<0)?(ax-mapX)*dX:(mapX+1-ax)*dX;
    let sY=(sin<0)?(ay-mapY)*dY:(mapY+1-ay)*dY;
    while(!hit && dist<max){
      if(sX<sY){ sX+=dX; mapX+=stepX; side=0; } else { sY+=dY; mapY+=stepY; side=1; }
      hitTile=tile(mapX,mapY);
      if(hitTile!==0){ hit=true; dist=(side===0)?(sX-dX):(sY-dY); }
    }
    return {dist:dist||max, side, tile:hitTile};
  }

  const player={x:5.5,y:5.5,a:0,fov:85*Math.PI/180,speed:6,rot:2.6};
  const keys={};
  addEventListener('keydown',e=>{ keys[e.code]=true; if(e.code==='Escape') togglePause(true); });
  addEventListener('keyup',e=>{ keys[e.code]=false; });

  let pointerLocked=false, pointerEnabled=false;
  req('#lockBtn').onclick=()=>{ if(!pointerEnabled) return; if(document.pointerLockElement===canvas){document.exitPointerLock();} else {canvas.requestPointerLock();} };
  addEventListener('pointerlockchange',()=>{ pointerLocked=(document.pointerLockElement===canvas); });
  addEventListener('mousemove',e=>{ if(pointerEnabled && pointerLocked && !showingPause){ player.a += (e.movementX||0)*0.0025*1.5; }});

  const pauseOverlay=req('#pauseOverlay'); let showingPause=false;
  req('#pauseBtn').onclick=()=>togglePause(true);
  req('#resumeBtn').onclick=()=>togglePause(false);
  req('#restartBtn').onclick=()=>{ round=1; spawnRound(); togglePause(false); };
  req('#quitBtn').onclick=()=>{ location.reload(); };
  function togglePause(show){ showingPause=show ?? !showingPause; pauseOverlay.style.display=showingPause?'flex':'none'; if(showingPause && document.pointerLockElement===canvas) document.exitPointerLock(); }

  let enemies=[], round=1;
  function randSpawn(){ for(let t=0;t<200;t++){ const x=2+Math.random()*(MAP_W-4), y=2+Math.random()*(MAP_H-4); if(tile(x,y)===0 && Math.hypot(x-player.x,y-player.y)>6) return {x,y}; } return {x:MAP_W-3,y:MAP_H-3}; }
  function spawnRound(){ enemies.length=0; const n=Math.min(6+round*2,40); for(let i=0;i<n;i++){ const p=randSpawn(); enemies.push({x:p.x,y:p.y,alive:true}); } }

  req('#startBtn').onclick=()=>{ running=true; pointerEnabled=true; spawnRound(); };
  req('#fsBtn').onclick=()=>{ if(!document.fullscreenElement){ (document.body.requestFullscreen||document.documentElement.requestFullscreen||canvas.requestFullscreen).call(document.body);} else { document.exitFullscreen&&document.exitFullscreen(); }};

  let last=performance.now();
  function loop(ts){
    const dt=Math.min(0.033,(ts-last)/1000); last=ts;
    if(running && !showingPause){
      const forward=(keys['KeyW']?1:0)-(keys['KeyS']?1:0);
      const strafe =(keys['KeyD']?1:0)-(keys['KeyA']?1:0);
      const turn   =(keys['ArrowRight']?1:0)-(keys['ArrowLeft']?1:0);
      player.a += turn*player.rot*dt;
      const dirx=Math.cos(player.a), diry=Math.sin(player.a);
      const strx=Math.cos(player.a+Math.PI/2), stry=Math.sin(player.a+Math.PI/2);
      const sp=player.speed*dt;
      player.x+=dirx*(forward*sp)+strx*(strafe*sp);
      player.y+=diry*(forward*sp)+stry*(strafe*sp);
      if(tile(player.x,player.y)!==0){ player.x=Math.min(Math.max(player.x,1.1),MAP_W-1.1); player.y=Math.min(Math.max(player.y,1.1),MAP_H-1.1); }
    }
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function render(){
    const sky=ctx.createLinearGradient(0,0,0,H/2); sky.addColorStop(0,'#6d83ff'); sky.addColorStop(1,'#2b2f73'); ctx.fillStyle=sky; ctx.fillRect(0,0,W,H/2);
    const floor=ctx.createLinearGradient(0,H/2,0,H); floor.addColorStop(0,'#2c3555'); floor.addColorStop(1,'#0b0f1f'); ctx.fillStyle=floor; ctx.fillRect(0,H/2,W,H/2);
    if(zbuf.length!==W) zbuf=new Float32Array(W);
    for(let x=0;x<W;x++){
      const cameraX=(2*x/W-1);
      const rayAng=player.a + cameraX*(player.fov/2)*2;
      const hit=castRay(player.x,player.y,rayAng,60);
      const dist=hit.dist*Math.cos(rayAng-player.a);
      zbuf[x]=dist;
      const lineH=Math.min(H, H/(dist+0.0001));
      const y0=(H-lineH)/2;
      let col=WALL_COL[hit.tile]||'#888'; if(hit.side) col=darken(col,0.75);
      ctx.fillStyle=col; ctx.fillRect(x,y0,1,lineH);
    }
    ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath();
    ctx.moveTo(W/2-8,H/2); ctx.lineTo(W/2+8,H/2);
    ctx.moveTo(W/2,H/2-8); ctx.lineTo(W/2,H/2+8); ctx.stroke();
  }
  function darken(hex,f){ const c=parseInt(hex.slice(1),16); let r=((c>>16)&255)*f|0,g=((c>>8)&255)*f|0,b=(c&255)*f|0; return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1); }
}

/* tiny DOM helper */
function req(sel){ const el=document.querySelector(sel); if(!el){ throw new Error('Missing element '+sel); } return el; }
</script>
</body>
</html>
