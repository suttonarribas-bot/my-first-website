<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retro FPS – Level 1</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#eee;font-family:system-ui,Arial}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:8px}
  canvas{width:100vw;max-width:900px;height:60vh;touch-action:none;background:#000}
  .hud{max-width:900px;width:100%;display:flex;justify-content:space-between;align-items:center;font-size:14px}
  .btn{padding:.4rem .7rem;border:1px solid #666;background:#222;color:#eee;border-radius:6px}
  /* Mobile touch zones */
  .zones{position:fixed;inset:0;pointer-events:none}
  .zone{position:absolute;top:0;height:100%;width:50%;pointer-events:auto}
  .left{left:0}
  .right{right:0}
  .toast{position:fixed;top:8px;left:50%;transform:translateX(-50%);background:#222;padding:.4rem .7rem;border:1px solid #555;border-radius:6px;opacity:.9}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="900" height="540"></canvas>
  <div class="hud">
    <div>
      <strong>Controls</strong>:
      WASD = move, ←/→ = look, Space = fire. On phone: left half = move, right half = look/tap to fire.
    </div>
    <button id="fireBtn" class="btn">FIRE (Space)</button>
  </div>
</div>

<div class="zones" aria-hidden="true">
  <div id="zoneLeft" class="zone left"></div>
  <div id="zoneRight" class="zone right"></div>
</div>
<div id="toast" class="toast" style="display:none;"></div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // ----- WORLD -----
  // 0 empty, 1/2/3 walls (different colors), 9 = EXIT (green door)
  const MAP_W = 16, MAP_H = 16;
  const map = [
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,2,0,0,0,0,9,1,
    1,0,2,2,0,0,0,0,0,2,0,0,3,0,0,1,
    1,0,0,2,0,0,3,3,0,2,0,0,3,0,0,1,
    1,0,0,2,0,0,0,3,0,2,0,0,0,0,0,1,
    1,0,0,2,0,0,0,3,0,2,0,0,0,0,0,1,
    1,0,0,2,0,0,0,0,0,2,0,0,0,0,0,1,
    1,0,0,0,0,3,3,3,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,2,2,2,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,
    1,0,0,0,0,0,0,3,3,3,0,0,0,2,0,1,
    1,0,0,0,0,0,0,0,0,3,0,0,0,2,0,1,
    1,0,0,0,0,0,0,0,0,3,0,0,0,2,0,1,
    1,0,0,0,0,0,0,0,0,3,0,0,0,2,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  ];
  const WALL_COL = {1:'#a33',2:'#339',3:'#993',9:'#1a3'}; // exit drawn separately

  // Simple enemies (billboards)
  const enemies = [
    {x: 6.5, y: 3.5, alive: true},
    {x: 11.5,y: 10.5, alive: true}
  ];

  // Player
  const player = {
    x: 2.5, y: 2.5, a: 0, // angle radians
    fov: Math.PI/3, speed: 3.0, rot: 2.4, // units/sec, rad/sec
  };

  // Timing
  let last = performance.now();

  // Input (keyboard)
  const keys = {};
  addEventListener('keydown', e => { keys[e.code]=true; if(e.code==='Space') shoot(); });
  addEventListener('keyup',   e => { keys[e.code]=false; });

  // Z-buffer for sprites
  let zbuf = new Float32Array(canvas.width);

  // Pointer / touch controls
  const left = document.getElementById('zoneLeft');
  const right = document.getElementById('zoneRight');
  let moveTouch = null, lookTouch = null;
  let moveVec = {x:0,y:0}, lookDelta = 0;
  function norm(v){ const m=Math.hypot(v.x,v.y)||1; return {x:v.x/m,y:v.y/m}; }
  function bindZone(el, cbStart, cbMove, cbEnd){
    el.addEventListener('pointerdown', e => { el.setPointerCapture(e.pointerId); cbStart(e); });
    el.addEventListener('pointermove', cbMove);
    el.addEventListener('pointerup', cbEnd);
    el.addEventListener('pointercancel', cbEnd);
  }
  bindZone(left,
    e => { if(moveTouch) return; moveTouch=e.pointerId; moveVec={x:0,y:0}; },
    e => { if(e.pointerId!==moveTouch) return; const r=left.getBoundingClientRect();
           const cx=r.left+r.width/2, cy=r.top+r.height/2;
           moveVec={x:(e.clientX-cx)/r.width*2, y:(e.clientY-cy)/r.height*2}; },
    e => { if(e.pointerId===moveTouch){ moveTouch=null; moveVec={x:0,y:0}; } }
  );
  bindZone(right,
    e => { if(lookTouch) return; lookTouch=e.pointerId; lookDelta=0; right._lastX=e.clientX; right._tapT=performance.now(); },
    e => { if(e.pointerId!==lookTouch) return;
           const dx=e.clientX-right._lastX; right._lastX=e.clientX; lookDelta+=dx; },
    e => { if(e.pointerId===lookTouch){
             // quick tap to fire
             if(performance.now()-right._tapT < 200) shoot();
             lookTouch=null; lookDelta=0;
           } }
  );

  // Button fire
  document.getElementById('fireBtn').onclick = () => shoot();

  // Utility
  function tile(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return 1; return map[(y|0)*MAP_W+(x|0)]; }
  function showToast(msg, ms=1400){
    const t=document.getElementById('toast');
    t.textContent=msg; t.style.display='block';
    clearTimeout(t._to); t._to=setTimeout(()=>t.style.display='none', ms);
  }

  // Raycast a single ray using DDA
  function castRay(ax, ay, ang, max=20){
    const sin=Math.sin(ang), cos=Math.cos(ang);
    let dist = 0, hit=false, side=0, hitTile=0;
    // DDA setup
    let mapX = Math.floor(ax), mapY = Math.floor(ay);
    const deltaDistX = Math.abs(1 / (cos||1e-6));
    const deltaDistY = Math.abs(1 / (sin||1e-6));
    let stepX = (cos<0)?-1:1, stepY=(sin<0)?-1:1;
    let sideDistX = (cos<0)? (ax-mapX)*deltaDistX : (mapX+1-ax)*deltaDistX;
    let sideDistY = (sin<0)? (ay-mapY)*deltaDistY : (mapY+1-ay)*deltaDistY;

    while(!hit && dist<max){
      if(sideDistX < sideDistY){ sideDistX+=deltaDistX; mapX+=stepX; side=0; }
      else { sideDistY+=deltaDistY; mapY+=stepY; side=1; }
      hitTile = tile(mapX, mapY);
      if(hitTile!==0){
        hit=true;
        dist = (side===0)? (sideDistX-deltaDistX) : (sideDistY-deltaDistY);
      }
    }
    return {dist: dist||max, side, tile:hitTile, mx:mapX, my:mapY};
  }

  // Shooting (hitscan toward crosshair)
  function shoot(){
    // Simple muzzle flash feedback
    flashTimer = 0.08;
    // Check visible enemy roughly under crosshair
    let hit = false;
    let closest = {d: 1e9, idx: -1};
    for(let i=0;i<enemies.length;i++){
      const e = enemies[i]; if(!e.alive) continue;
      const dx=e.x-player.x, dy=e.y-player.y;
      const dist=Math.hypot(dx,dy);
      const angTo=Math.atan2(dy,dx);
      let da=((angTo-player.a+Math.PI*3)%(Math.PI*2))-Math.PI; // normalize
      if(Math.abs(da) < player.fov*0.06 && dist<8){ // near center
        // walls block?
        const ray = castRay(player.x, player.y, player.a, 20);
        if(ray.dist+0.05 >= dist){ // enemy not behind wall
          if(dist < closest.d){ closest={d:dist, idx:i}; }
        }
      }
    }
    if(closest.idx>=0){
      enemies[closest.idx].alive=false;
      showToast('Enemy down!');
      hit = true;
    }
    if(!hit) showToast('Miss');
  }

  // Resize for crisp rendering
  function fitCanvas(){
    const dpr = Math.min(2, (window.devicePixelRatio||1));
    const cssW = Math.min(window.innerWidth, 900);
    const cssH = Math.floor(cssW*0.6);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.floor(cssW*dpr);
    canvas.height = Math.floor(cssH*dpr);
  }
  fitCanvas();
  addEventListener('resize', fitCanvas);

  let flashTimer = 0;

  // ----- MAIN LOOP -----
  function loop(ts){
    const dt = Math.min(0.033, (ts-last)/1000); last = ts;

    // Movement (keyboard)
    const forward = (keys['KeyW']?1:0) - (keys['KeyS']?1:0);
    const strafe  = (keys['KeyD']?1:0) - (keys['KeyA']?1:0);
    const turn    = (keys['ArrowRight']?1:0) - (keys['ArrowLeft']?1:0);

    // Movement (touch)
    const mv = norm(moveVec);
    const look = lookDelta; lookDelta = 0;

    // Rotate
    player.a += (turn*player.rot*dt) + (look * 0.004);

    // Move
    const sp = player.speed*dt;
    const dirx = Math.cos(player.a), diry = Math.sin(player.a);
    const strx = Math.cos(player.a+Math.PI/2), stry = Math.sin(player.a+Math.PI/2);
    let vx = dirx*(forward*sp) + strx*(strafe*sp) + (mv.x*sp*1.2);
    let vy = diry*(forward*sp) + stry*(strafe*sp) + (mv.y*sp*1.2);

    // simple collision
    const nx = player.x + vx, ny = player.y + vy;
    if(tile(nx, player.y)===0) player.x = nx;
    if(tile(player.x, ny)===0) player.y = ny;

    // Check exit
    const tx = Math.floor(player.x), ty = Math.floor(player.y);
    if(tile(tx,ty)===9 && Math.hypot(player.x-(tx+0.5), player.y-(ty+0.5))<0.7){
      winScreen(); return;
    }

    // Render
    render(dt);
    requestAnimationFrame(loop);
  }

  function render(dt){
    const W = canvas.width, H = canvas.height;
    // Sky & floor
    const sky = ctx.createLinearGradient(0,0,0,H/2);
    sky.addColorStop(0,'#334'); sky.addColorStop(1,'#112');
    ctx.fillStyle = sky; ctx.fillRect(0,0,W,H/2);
    const floor = ctx.createLinearGradient(0,H/2,0,H);
    floor.addColorStop(0,'#222'); floor.addColorStop(1,'#000');
    ctx.fillStyle = floor; ctx.fillRect(0,H/2,W,H/2);

    // Walls via ray casting (one vertical slice per column)
    const cols = W|0;
    zbuf = zbuf.length===cols ? zbuf : new Float32Array(cols);
    for(let x=0;x<cols;x++){
      const cameraX = (2*x/cols - 1); // -1..1
      const rayAng = player.a + cameraX * player.fov/2 * 2;
      const hit = castRay(player.x, player.y, rayAng, 20);
      const dist = hit.dist * Math.cos(rayAng - player.a); // fix fisheye
      zbuf[x] = dist;

      const lineH = Math.min(H, (H / (dist+0.0001)));
      const y0 = (H - lineH)/2;

      // Color
      let col = WALL_COL[hit.tile] || '#777';
      // darken if side
      if(hit.side) col = shade(col, 0.7);
      // highlight exit
      if(hit.tile===9) col = '#2f5';

      ctx.fillStyle = col;
      ctx.fillRect(x, y0, 1, lineH);
    }

    // Sprites (enemies)
    const visible = [];
    for(const e of enemies){
      if(!e.alive) continue;
      const dx=e.x-player.x, dy=e.y-player.y;
      const dist=Math.hypot(dx,dy);
      const ang=Math.atan2(dy,dx)-player.a;
      let a=((ang+Math.PI*3)%(Math.PI*2))-Math.PI;
      if(Math.abs(a) < player.fov*0.6 && dist>0.2){
        visible.push({e,dist,a});
      }
    }
    visible.sort((a,b)=>b.dist-a.dist);
    for(const v of visible){
      const size = Math.min(H, H/(v.dist));
      const sx = ( (v.a/(player.fov))* (canvas.width/2) ) + canvas.width/2;
      const half = size/2;
      const x0 = (sx-half)|0, x1=(sx+half)|0;
      // clip by zbuffer
      ctx.fillStyle = '#f44';
      for(let x=Math.max(0,x0); x<Math.min(canvas.width,x1); x++){
        if(v.dist < zbuf[x]-0.01){
          ctx.fillRect(x, (H/2 - size*0.9), 1, size*0.9*2);
        }
      }
    }

    // Crosshair
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(W/2-8,H/2); ctx.lineTo(W/2+8,H/2);
    ctx.moveTo(W/2,H/2-8); ctx.lineTo(W/2,H/2+8);
    ctx.stroke();

    // Muzzle flash
    if(flashTimer>0){
      ctx.fillStyle='rgba(255,255,200,0.18)';
      ctx.fillRect(0,0,W,H);
      flashTimer -= dt;
    }

    // Mini-map (top-left)
    const cell = 6, off=10;
    ctx.fillStyle='#0008';
    ctx.fillRect(off-2,off-2,MAP_W*cell+4,MAP_H*cell+4);
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W;x++){
        const t = map[y*MAP_W+x];
        ctx.fillStyle = t? '#666' : '#111';
        if(t===9) ctx.fillStyle='#2f5';
        ctx.fillRect(off+x*cell, off+y*cell, cell-1, cell-1);
      }
    }
    // enemies on map
    for(const e of enemies){
      ctx.fillStyle = e.alive ? '#f44' : '#555';
      ctx.fillRect(off+e.x*cell-1, off+e.y*cell-1, 3,3);
    }
    // player arrow
    ctx.fillStyle='#4cf';
    ctx.beginPath();
    const px = off+player.x*cell, py=off+player.y*cell;
    ctx.arc(px,py,2,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#4cf'; ctx.beginPath();
    ctx.moveTo(px,py);
    ctx.lineTo(px+Math.cos(player.a)*8, py+Math.sin(player.a)*8);
    ctx.stroke();
  }

  function shade(hex, f){
    const c = parseInt(hex.slice(1),16);
    let r=((c>>16)&255)*f|0, g=((c>>8)&255)*f|0, b=(c&255)*f|0;
    return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
  }

  function winScreen(){
    const W=canvas.width,H=canvas.height;
    ctx.fillStyle='#020'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#2f5'; ctx.textAlign='center';
    ctx.font = Math.floor(H*0.08)+'px system-ui,Arial';
    ctx.fillText('LEVEL COMPLETE', W/2, H/2);
    ctx.font = Math.floor(H*0.035)+'px system-ui,Arial';
    ctx.fillText('You reached the exit!', W/2, H/2+50);
  }

  showToast('Find the green exit. Tap/Space to shoot.');
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
