<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retro Arena+ — Rounds, Upgrades, Jump</title>
<style>
  html,body{margin:0;height:100%;background:#0a0c12;color:#eee;font-family:system-ui,Arial}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:8px}
  canvas{width:100vw;max-width:1000px;height:60vh;background:#000;touch-action:none;cursor:crosshair}
  .hud{max-width:1000px;width:100%;display:flex;flex-wrap:wrap;gap:10px;align-items:center;font-size:14px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{padding:.5rem .8rem;border:1px solid #666;background:#1f2330;color:#eee;border-radius:8px;cursor:pointer}
  .slider{display:flex;gap:8px;align-items:center}
  .slider input{width:170px;height:30px}
  .value{min-width:44px;text-align:right}
  .spacer{flex:1}

  /* Touch zones */
  .zones{position:fixed;inset:0;pointer-events:none}
  .zone{position:absolute;top:0;height:100%;width:50%;pointer-events:auto}
  .left{left:0}
  .right{right:0}

  /* Overlays */
  .toast{position:fixed;top:8px;left:50%;transform:translateX(-50%);background:#1f2330;padding:.5rem .8rem;border:1px solid #555;border-radius:8px;opacity:.95}
  .overlay{
    position:fixed;inset:0;background:rgba(0,0,0,.66);
    display:none;align-items:center;justify-content:center;padding:16px;z-index:10
  }
  .panel{
    background:#141824;border:1px solid #41465a;border-radius:12px;padding:16px;max-width:900px;width:95%;
    box-shadow:0 8px 32px rgba(0,0,0,.5)
  }
  .panel h2{margin:0 0 8px 0}
  .choices{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin-top:10px}
  .choice{border:1px solid #4a516a;background:#192035;border-radius:10px;padding:12px;cursor:pointer}
  .choice:hover{background:#202742}
  .meta{opacity:.85;font-size:13px}
  .tree{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .tag{background:#26304b;border:1px solid #445079;padding:.18rem .45rem;border-radius:999px;font-size:12px}

  /* On-screen help */
  .help{max-width:1000px;width:100%;opacity:.9;font-size:13px}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1000" height="600" aria-label="Arena view"></canvas>

  <div class="hud" role="group" aria-label="Controls">
    <div class="row">
      <button id="fireBtn" class="btn" title="Left click / tap">Fire</button>
      <button id="jumpBtn" class="btn" title="Space / double-tap right">Jump</button>
      <button id="reloadBtn" class="btn" title="R">Reload</button>
      <button id="fsBtn" class="btn" title="Fullscreen">Fullscreen</button>
      <button id="musicBtn" class="btn" title="Toggle music">Music: Off</button>
      <button id="sfxBtn" class="btn" title="Toggle SFX">SFX: On</button>
      <button id="lockBtn" class="btn" title="Pointer lock (desktop)">Mouse Look</button>
    </div>
    <div class="spacer"></div>
    <div class="row" role="group" aria-label="Settings">
      <div class="slider">
        <label for="fov">FOV</label>
        <input id="fov" type="range" min="55" max="110" step="1" value="85">
        <span id="fovVal" class="value">85°</span>
      </div>
      <div class="slider">
        <label for="sens">Sensitivity</label>
        <input id="sens" type="range" min="60" max="300" step="1" value="150">
        <span id="sensVal" class="value">1.50</span>
      </div>
      <div class="slider">
        <label for="bright">Brightness</label>
        <input id="bright" type="range" min="90" max="180" step="1" value="145">
        <span id="brightVal" class="value">1.45</span>
      </div>
    </div>
    <div class="help">Desktop: <strong>WASD</strong> to move, <strong>Mouse</strong> or ←/→ to look, <strong>Left-click</strong> to fire, <strong>Space</strong> to jump, <strong>R</strong> to reload, <strong>L</strong> to toggle mouse-lock. Phone: drag left to move, drag right to look, tap right to fire, double-tap right to jump.</div>
  </div>
</div>

<!-- Touch zones -->
<div class="zones" aria-hidden="true">
  <div id="zoneLeft" class="zone left"></div>
  <div id="zoneRight" class="zone right"></div>
</div>

<!-- Intermission / upgrades -->
<div id="overlay" class="overlay" role="dialog" aria-modal="true">
  <div class="panel">
    <h2 id="overlayTitle">Round Cleared</h2>
    <div class="meta" id="overlayMeta"></div>
    <div style="margin-top:10px">Pick one upgrade:</div>
    <div class="choices" id="choices"></div>
    <div style="margin-top:10px">
      <div class="meta">Keys: 1 / 2 / 3 to pick fast</div>
      <div class="tree" id="tree"></div>
    </div>
  </div>
</div>

<div id="toast" class="toast" style="display:none;"></div>

<script>
(()=>{
// =========================================================
// Core setup
// =========================================================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let zbuf = new Float32Array(canvas.width);

// Settings
const settings = {
  fovDeg: getNum('arena_fov', 85),
  sensitivity: getNum('arena_sens', 1.5),
  brightness: getNum('arena_bright', 1.45),
  sfx: getNum('arena_sfx', 1) ? true : false,
  music: getNum('arena_music', 0) ? true : false,
};
function getNum(k,d){const v=localStorage.getItem(k); return v?+v:d;}
function setNum(k,v){localStorage.setItem(k,v);}

// World (brighter palette, obstacles: 2=pillars, 3=crates (jumpable), 4=pit)
const MAP_W=28, MAP_H=24;
const map = new Array(MAP_W*MAP_H).fill(0);
function idx(x,y){return y*MAP_W+x;}
for(let x=0;x<MAP_W;x++){ map[idx(x,0)]=1; map[idx(x,MAP_H-1)]=1; }
for(let y=0;y<MAP_H;y++){ map[idx(0,y)]=1; map[idx(MAP_W-1,y)]=1; }
// pillars
const pillars=[[6,6],[6,17],[12,12],[20,6],[20,17],[14,5],[14,18]];
for(const [px,py] of pillars){ for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++) map[idx(px+dx,py+dy)]=2; }
// crates (jump over)
const crates=[[9,8],[10,8],[11,8],[16,10],[16,11],[16,12],[7,15],[8,15],[9,15]];
for(const [x,y] of crates) map[idx(x,y)]=3;
// pits (slow you unless you jump)
const pits=[[4,11],[5,11],[6,11],[7,11],[8,11],[19,14],[20,14],[21,14]];
for(const [x,y] of pits) map[idx(x,y)]=4;

// Colors
const WALL_COL = {
  1:'#7bd3ff', // outer cyan wall
  2:'#ffb36b', // orange pillars
  3:'#9be070', // lime crates (jumpable)
  4:'#303848'  // dark pit
};

function tile(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return 1; return map[(y|0)*MAP_W+(x|0)]; }
function shade(hex, f){
  const c=parseInt(hex.slice(1),16);
  let r=((c>>16)&255)*f|0, g=((c>>8)&255)*f|0, b=(c&255)*f|0;
  r=Math.min(255,Math.max(0,r)); g=Math.min(255,Math.max(0,g)); b=Math.min(255,Math.max(0,b));
  return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
}
function showToast(msg, ms=1200){
  const t=document.getElementById('toast');
  t.textContent=msg; t.style.display='block';
  clearTimeout(t._to); t._to=setTimeout(()=>t.style.display='none', ms);
}

// Player
const player = {
  x: 5.5, y: 5.5, a: 0,
  fov: settings.fovDeg*Math.PI/180,
  speed: 6.4,
  rot: 2.6,
  hp: 110, maxHp: 110,
  vz: 0,     // vertical velocity for jump
  z: 0,      // camera height offset
  grounded: true,
};

// Weapon & combat
const weapon = {
  damage: 1,
  fireRate: 3.0,    // shots/sec
  pierce: 0,
  cooldown: 0,
  critMult: 2.0,    // headshot multiplier
  magSize: 10,
  ammoInMag: 10,
  reserve: 90,
  reloadTime: 1.3,
  reloading: 0,
};

// Rounds & enemies
let round = 1;
let kills = 0;
let enemies = [];
let projectiles = []; // enemy bullets

// Enemy types (colors)
const ENEMY_TYPES = {
  melee: { name:'Melee',  baseHp:1,  color:'#ff5e66', speed:1.25, touchDmg:9, range:0,  rof:0 },
  fast:  { name:'Runner', baseHp:1,  color:'#59ff9c', speed:1.85, touchDmg:7, range:0,  rof:0 },
  tank:  { name:'Tank',   baseHp:4,  color:'#b071ff', speed:0.95, touchDmg:14,range:0,  rof:0 },
  ranged:{ name:'Ranger', baseHp:2,  color:'#5ec5ff', speed:1.2,  touchDmg:5, range:14, rof:0.6 }, // shoots
};

function spawnRound(){
  enemies.length = 0;
  projectiles.length = 0;
  const count = Math.min(8 + round*2, 80);
  for(let i=0;i<count;i++){
    const pos = randSpawn();
    const pick = pickEnemyType(round);
    const t = ENEMY_TYPES[pick];
    enemies.push({
      type: pick,
      x: pos.x, y: pos.y, alive: true,
      hp: t.baseHp + Math.floor((round-1)/3),
      speed: t.speed + Math.min(0.8, (round-1)*0.05),
      touchDmg: t.touchDmg + Math.floor(round*0.3),
      fireTimer: 0, // for ranged
    });
  }
}
function pickEnemyType(r){
  const roll = Math.random();
  const rR = Math.min(0.35, 0.12 + r*0.02);
  const tR = Math.min(0.30, 0.08 + r*0.02);
  const fR = Math.min(0.35, 0.12 + r*0.02);
  if(roll < rR) return 'ranged';
  if(roll < rR+fR) return 'fast';
  if(roll < rR+fR+tR) return 'tank';
  return 'melee';
}
function randSpawn(){
  for(let t=0;t<300;t++){
    const x=2+Math.random()*(MAP_W-4);
    const y=2+Math.random()*(MAP_H-4);
    const tt=tile(x,y);
    if(tt===0 || tt===4){ // can spawn over pit too
      if(Math.hypot(x-player.x,y-player.y)>7) return {x,y};
    }
  }
  return {x:MAP_W-3,y:MAP_H-3};
}

// Input
const keys = {};
const keyBlock = new Set(['Space','KeyR','KeyL','ArrowLeft','ArrowRight','ArrowUp','ArrowDown','KeyW','KeyA','KeyS','KeyD','Digit1','Digit2','Digit3']);
addEventListener('keydown', e=>{
  keys[e.code]=true;
  if(keyBlock.has(e.code)) e.preventDefault();
  if(e.code==='KeyR') reload();
  if(e.code==='Space') jump();
  if(showingOverlay){
    if(e.code==='Digit1') pickUpgrade(0);
    if(e.code==='Digit2') pickUpgrade(1);
    if(e.code==='Digit3') pickUpgrade(2);
  }
});
addEventListener('keyup', e=>{
  keys[e.code]=false;
  if(keyBlock.has(e.code)) e.preventDefault();
});

// Pointer-lock mouse look (desktop)
let pointerLocked = false;
document.getElementById('lockBtn').onclick = togglePointerLock;
canvas.addEventListener('click', e=>{ if(!pointerLocked) togglePointerLock(); fire(); });
function togglePointerLock(){
  if (document.pointerLockElement === canvas){ document.exitPointerLock(); }
  else { canvas.requestPointerLock(); }
}
document.addEventListener('pointerlockchange', ()=>{
  pointerLocked = (document.pointerLockElement === canvas);
});
document.addEventListener('mousemove', e=>{
  if(pointerLocked){
    player.a += (e.movementX||0)*0.0025*settings.sensitivity;
  }
});

// Touch controls
const leftZone=document.getElementById('zoneLeft'), rightZone=document.getElementById('zoneRight');
let moveTouch=null, lookTouch=null;
let moveVec={x:0,y:0}, lookDX=0, lastTap=0;
function bindZone(el, start, move, end){
  el.addEventListener('pointerdown', e=>{ el.setPointerCapture(e.pointerId); start(e); });
  el.addEventListener('pointermove', e=>move(e));
  el.addEventListener('pointerup', e=>end(e));
  el.addEventListener('pointercancel', e=>end(e));
}
bindZone(leftZone,
  e=>{ if(moveTouch) return; moveTouch=e.pointerId; moveVec={x:0,y:0}; },
  e=>{ if(e.pointerId!==moveTouch) return; const r=leftZone.getBoundingClientRect();
       const cx=r.left+r.width/2, cy=r.top+r.height/2;
       moveVec={x:(e.clientX-cx)/r.width*2, y:(e.clientY-cy)/r.height*2}; },
  e=>{ if(e.pointerId===moveTouch){ moveTouch=null; moveVec={x:0,y:0}; } }
);
bindZone(rightZone,
  e=>{ if(lookTouch) return; lookTouch=e.pointerId; rightZone._lastX=e.clientX;
       const now=performance.now(); if(now-lastTap<250){ jump(); } lastTap=now; },
  e=>{ if(e.pointerId!==lookTouch) return;
       const dx=e.clientX-rightZone._lastX; rightZone._lastX=e.clientX; lookDX+=dx; },
  e=>{ if(e.pointerId===lookTouch){ fire(); lookTouch=null; } }
);

// Buttons
document.getElementById('fireBtn').onclick=()=>fire();
document.getElementById('jumpBtn').onclick=()=>jump();
document.getElementById('reloadBtn').onclick=()=>reload();
const fsBtn=document.getElementById('fsBtn');
fsBtn.onclick=()=>{ if(!document.fullscreenElement){ (document.body.requestFullscreen||document.documentElement.requestFullscreen||canvas.requestFullscreen).call(document.body); } else document.exitFullscreen&&document.exitFullscreen(); };
document.addEventListener('fullscreenchange', fitCanvas);

const musicBtn=document.getElementById('musicBtn');
const sfxBtn=document.getElementById('sfxBtn');
musicBtn.onclick=()=>{ settings.music=!settings.music; setNum('arena_music',settings.music?1:0); musicBtn.textContent='Music: '+(settings.music?'On':'Off'); if(settings.music) startMusic(); else stopMusic(); };
sfxBtn.onclick=()=>{ settings.sfx=!settings.sfx; setNum('arena_sfx',settings.sfx?1:0); sfxBtn.textContent='SFX: '+(settings.sfx?'On':'Off'); };

// Sliders
const fovEl=q('#fov'), fovVal=q('#fovVal');
const sensEl=q('#sens'), sensVal=q('#sensVal');
const brightEl=q('#bright'), brightVal=q('#brightVal');
fovEl.value=settings.fovDeg; fovVal.textContent=settings.fovDeg+'°';
sensEl.value=Math.round(settings.sensitivity*100); sensVal.textContent=settings.sensitivity.toFixed(2);
brightEl.value=Math.round(settings.brightness*100); brightVal.textContent=settings.brightness.toFixed(2);
fovEl.addEventListener('input',()=>{ settings.fovDeg=+fovEl.value; player.fov=settings.fovDeg*Math.PI/180; fovVal.textContent=settings.fovDeg+'°'; setNum('arena_fov',settings.fovDeg); });
sensEl.addEventListener('input',()=>{ settings.sensitivity=(+sensEl.value)/100; sensVal.textContent=settings.sensitivity.toFixed(2); setNum('arena_sens',settings.sensitivity); });
brightEl.addEventListener('input',()=>{ settings.brightness=(+brightEl.value)/100; brightVal.textContent=settings.brightness.toFixed(2); setNum('arena_bright',settings.brightness); });

// Overlay / upgrades
const overlay=q('#overlay'), overlayTitle=q('#overlayTitle'), overlayMeta=q('#overlayMeta'), choicesEl=q('#choices'), treeEl=q('#tree');
let showingOverlay=false;
let upgradeTags=[];
const U = {
  dmg: {name:'+Damage',desc:'+1 weapon damage',apply:()=>weapon.damage+=1},
  rate:{name:'+Fire Rate',desc:'+20% fire rate',apply:()=>weapon.fireRate*=1.2},
  pier:{name:'Pierce +1',desc:'Bullets pierce +1 target',apply:()=>weapon.pierce+=1},
  speed:{name:'Dash Boots',desc:'+12% move speed',apply:()=>player.speed*=1.12},
  hp:{name:'Thicker Skin',desc:'+20 max HP & heal 20',apply:()=>{player.maxHp+=20;player.hp=Math.min(player.maxHp,player.hp+20);}},
  mag:{name:'Bigger Mag',desc:'+30% mag size',apply:()=>{weapon.magSize=Math.max(1,Math.round(weapon.magSize*1.3)); weapon.ammoInMag=weapon.magSize;}},
  stock:{name:'Ammo Stock',desc:'+60 reserve ammo',apply:()=>weapon.reserve+=60},
  crit:{name:'Sharpshot',desc:'Headshots x2.5 dmg',apply:()=>weapon.critMult=2.5},
  regen:{name:'Regenerate',desc:'Heal 1 HP/sec out of combat',apply:()=>regenActive=true},
};
const upgradePool=[U.dmg,U.rate,U.pier,U.speed,U.hp,U.mag,U.stock,U.crit,U.regen];
let regenActive=false;
function randomChoices(n=3){
  const pool=[...upgradePool];
  const picks=[];
  for(let i=0;i<n&&pool.length;i++){
    const k=Math.floor(Math.random()*pool.length);
    picks.push(pool.splice(k,1)[0]);
  }
  return picks;
}
let pickUpgrade=()=>{};
function showUpgradeOverlay(){
  showingOverlay=true; overlay.style.display='flex';
  overlayTitle.textContent=`Round ${round} cleared`;
  overlayMeta.textContent = `Kills: ${kills}  •  Weapon: dmg ${weapon.damage}, ROF ${weapon.fireRate.toFixed(2)}/s, pierce ${weapon.pierce}, mag ${weapon.ammoInMag}/${weapon.magSize}, reserve ${weapon.reserve}`;
  const picks=randomChoices(3);
  choicesEl.innerHTML='';
  picks.forEach((u,idx)=>{
    const d=document.createElement('div');
    d.className='choice';
    d.innerHTML=`<strong>${idx+1}) ${u.name}</strong><div class="meta">${u.desc}</div>`;
    d.onclick=()=>{ u.apply(); upgradeTags.push(u.name); renderTree(); nextRound(); };
    choicesEl.appendChild(d);
  });
  pickUpgrade=(n)=>{ if(picks[n]){ picks[n].apply(); upgradeTags.push(picks[n].name); renderTree(); nextRound(); } };
  renderTree();
}
function renderTree(){
  treeEl.innerHTML='';
  upgradeTags.forEach(t=>{
    const s=document.createElement('span');
    s.className='tag'; s.textContent=t;
    treeEl.appendChild(s);
  });
}
function nextRound(){
  overlay.style.display='none'; showingOverlay=false;
  round++;
  // small heal between rounds
  player.hp=Math.min(player.maxHp, player.hp+15);
  spawnRound();
}

// Audio (simple WebAudio beeps)
let ac=null, musicOsc=null;
function AC(){ if(!ac){ ac=new (window.AudioContext||window.webkitAudioContext)(); } return ac; }
function sfx(freq=600, dur=0.06, type='square', vol=0.15){
  if(!settings.sfx) return;
  const a=AC(), o=a.createOscillator(), g=a.createGain();
  o.type=type; o.frequency.value=freq;
  g.gain.value=vol;
  o.connect(g); g.connect(a.destination);
  const t=a.currentTime; o.start(t); o.stop(t+dur);
  g.gain.setValueAtTime(vol,t);
  g.gain.exponentialRampToValueAtTime(0.001,t+dur);
}
function startMusic(){
  if(!settings.music) return;
  const a=AC(); stopMusic();
  musicOsc=a.createOscillator();
  const g=a.createGain(); g.gain.value=0.06;
  // simple two-note pulse
  musicOsc.type='triangle';
  musicOsc.frequency.value=140;
  const lfo=a.createOscillator(), lfoGain=a.createGain();
  lfo.frequency.value=0.5; lfoGain.gain.value=40;
  lfo.connect(lfoGain); lfoGain.connect(musicOsc.frequency);
  musicOsc.connect(g); g.connect(a.destination);
  const t=a.currentTime; musicOsc.start(t); lfo.start(t);
}
function stopMusic(){ if(musicOsc){ try{musicOsc.stop();}catch{} musicOsc=null; } }

// UI init states
document.getElementById('musicBtn').textContent='Music: '+(settings.music?'On':'Off');
document.getElementById('sfxBtn').textContent='SFX: '+(settings.sfx?'On':'Off');
if(settings.music) startMusic();

// Resize / DPR
function fitCanvas(){
  const dpr=Math.min(2,window.devicePixelRatio||1);
  const cssW=Math.min(window.innerWidth,1000);
  const cssH=Math.floor(cssW*0.6);
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  canvas.width=Math.floor(cssW*dpr); canvas.height=Math.floor(cssH*dpr);
  zbuf = new Float32Array(canvas.width);
}
fitCanvas(); addEventListener('resize', fitCanvas);

// Timing
let last=performance.now();
let flashTimer=0, timeSinceHit=0;

// =========================================================
// Gameplay
// =========================================================
function reload(){
  if(weapon.reloading>0) return;
  if(weapon.ammoInMag>=weapon.magSize) return;
  if(weapon.reserve<=0) { showToast('No reserve'); sfx(200,0.08,'sawtooth',0.08); return; }
  weapon.reloading=weapon.reloadTime;
  sfx(300,0.12,'triangle',0.12);
}
function jump(){
  if(player.grounded){
    player.vz = 5.0; player.grounded=false; sfx(220,0.06,'square',0.06);
  }
}
function fire(){
  if(showingOverlay) return;
  if(weapon.reloading>0) return;
  if(weapon.cooldown>0) return;
  if(weapon.ammoInMag<=0){ sfx(120,0.06,'square',0.08); reload(); return; }
  weapon.cooldown = 1/weapon.fireRate;
  weapon.ammoInMag--;
  flashTimer=0.06;
  sfx(800,0.05,'square',0.12);

  // hitscan — collect visible enemies near center, sort by distance
  const candidates=[];
  for(let i=0;i<enemies.length;i++){
    const e=enemies[i]; if(!e.alive) continue;
    const dx=e.x-player.x, dy=e.y-player.y, dist=Math.hypot(dx,dy);
    const angTo=Math.atan2(dy,dx);
    let da=((angTo-player.a+Math.PI*3)%(Math.PI*2))-Math.PI;
    if(Math.abs(da)<player.fov*0.06 && dist<24){
      // wall occlusion
      const ray=castRay(player.x,player.y,player.a,40);
      if(ray.dist+0.05>=dist) candidates.push({i,dist});
    }
  }
  candidates.sort((a,b)=>a.dist-b.dist);

  // headshot check: reward very close alignment (tighter window)
  let pierLeft=weapon.pierce, hit=false;
  for(const c of candidates){
    const e=enemies[c.i]; if(!e.alive) continue;
    const dx=e.x-player.x, dy=e.y-player.y, dist=Math.hypot(dx,dy);
    const angTo=Math.atan2(dy,dx); let da=((angTo-player.a+Math.PI*3)%(Math.PI*2))-Math.PI;
    const head = Math.abs(da) < player.fov*0.02 ? true : false;
    const dmg = head ? Math.ceil(weapon.damage*weapon.critMult) : weapon.damage;
    e.hp -= dmg; hit=true;
    if(head) showToast('Headshot!',400);
    if(e.hp<=0){ e.alive=false; kills++; sfx(200,0.05,'triangle',0.1); }
    if(pierLeft<=0) break; pierLeft--;
  }
  if(!hit) showToast('Miss',400);
}

function castRay(ax,ay,ang,max=50){
  const sin=Math.sin(ang), cos=Math.cos(ang);
  let dist=0, hit=false, side=0, hitTile=0;
  let mapX=Math.floor(ax), mapY=Math.floor(ay);
  const deltaX=Math.abs(1/(cos||1e-6)), deltaY=Math.abs(1/(sin||1e-6));
  let stepX=(cos<0)?-1:1, stepY=(sin<0)?-1:1;
  let sideX=(cos<0)?(ax-mapX)*deltaX:(mapX+1-ax)*deltaX;
  let sideY=(sin<0)?(ay-mapY)*deltaY:(mapY+1-ay)*deltaY;
  while(!hit && dist<max){
    if(sideX<sideY){ sideX+=deltaX; mapX+=stepX; side=0; }
    else { sideY+=deltaY; mapY+=stepY; side=1; }
    hitTile = tile(mapX,mapY);
    if(hitTile!==0){ hit=true; dist=(side===0)?(sideX-deltaX):(sideY-deltaY); }
  }
  return {dist:dist||max, side, tile:hitTile};
}

function tryMove(obj,vx,vy,canHop=false){
  const pad=0.2;
  let nx=obj.x+vx, ny=obj.y+vy;
  // Handle crates (3): block unless player is mid-jump (z>0.6)
  const hop = canHop && player.z>0.6;
  const tx = (x,y)=>tile(x,y);

  // X axis
  let nextTileX=tx(nx+Math.sign(vx)*pad,obj.y);
  if(nextTileX===0 || nextTileX===4 || (nextTileX===3 && hop)) obj.x=nx;

  // Y axis
  let nextTileY=tx(obj.x,ny+Math.sign(vy)*pad);
  if(nextTileY===0 || nextTileY===4 || (nextTileY===3 && hop)) obj.y=ny;
}

// Physics & AI
function update(dt){
  // Cooldowns/reload
  if(weapon.cooldown>0) weapon.cooldown=Math.max(0,weapon.cooldown-dt);
  if(weapon.reloading>0){
    weapon.reloading=Math.max(0,weapon.reloading-dt);
    if(weapon.reloading===0){
      const need=weapon.magSize-weapon.ammoInMag;
      const take=Math.min(need, weapon.reserve);
      weapon.ammoInMag+=take; weapon.reserve-=take;
      sfx(500,0.08,'square',0.08);
    }
  }

  // Regen
  if(regenActive && timeSinceHit>2 && player.hp>0){
    player.hp=Math.min(player.maxHp, player.hp + 1*dt);
  }

  // Input
  const forward=(keys['KeyW']?1:0)-(keys['KeyS']?1:0);
  const strafe =(keys['KeyD']?1:0)-(keys['KeyA']?1:0);
  const turn   =(keys['ArrowRight']?1:0)-(keys['ArrowLeft']?1:0);
  const dirx=Math.cos(player.a), diry=Math.sin(player.a);
  const strx=Math.cos(player.a+Math.PI/2), stry=Math.sin(player.a+Math.PI/2);
  const mv = norm(moveVec);
  const look = lookDX; lookDX=0;

  // Rotate
  player.a += turn*player.rot*dt + look*0.004*settings.sensitivity;

  // Move
  const baseSp=player.speed*dt;
  let vx=dirx*(forward*baseSp) + strx*(strafe*baseSp) + (mv.x*baseSp*1.2);
  let vy=diry*(forward*baseSp) + stry*(strafe*baseSp) + (mv.y*baseSp*1.2);

  // Pits slow unless jumping
  const under=tile(player.x,player.y);
  const slow = (under===4 && player.z<0.2) ? 0.55 : 1.0;
  vx*=slow; vy*=slow;

  tryMove(player, vx, vy, /*canHop*/true);

  // Jump physics
  if(!player.grounded){
    player.vz -= 12*dt;           // gravity
    player.z += player.vz*dt;
    if(player.z<=0){ player.z=0; player.vz=0; player.grounded=true; }
  }

  // Enemies
  for(const e of enemies){
    if(!e.alive) continue;
    const dx=player.x-e.x, dy=player.y-e.y;
    const d=Math.hypot(dx,dy)||1;
    const sp=e.speed*dt;
    // basic steering toward player
    tryMove(e, (dx/d)*sp, (dy/d)*sp, false);

    // Contact damage
    if(d<0.65){
      const dmg=e.touchDmg*dt;
      if(dmg>0){ player.hp=Math.max(0,player.hp-dmg); timeSinceHit=0; }
    }

    // Ranged attack
    if(e.type==='ranged'){
      e.fireTimer = (e.fireTimer||0) - dt;
      const ET = ENEMY_TYPES.ranged;
      if(d<ET.range && e.fireTimer<=0){
        e.fireTimer = 1/Math.max(0.2, ET.rof + (round*0.02));
        const ang=Math.atan2(dy,dx);
        projectiles.push({x:e.x,y:e.y, vx:Math.cos(ang)*7, vy:Math.sin(ang)*7, color:'#80c8ff', ttl:3, dmg:8});
        sfx(600,0.04,'triangle',0.06);
      }
    }
  }

  // Projectiles
  for(const p of projectiles){
    p.ttl-=dt;
    p.x+=p.vx*dt; p.y+=p.vy*dt;
    // hit walls
    const t=tile(p.x,p.y);
    if(t!==0 && t!==4){ p.ttl=0; continue; }
    // hit player
    const d=Math.hypot(p.x-player.x,p.y-player.y);
    if(d<0.5){
      player.hp=Math.max(0,player.hp-p.dmg);
      p.ttl=0; timeSinceHit=0; sfx(140,0.04,'square',0.08);
    }
  }
  projectiles = projectiles.filter(p=>p.ttl>0);

  // Round clear
  if(enemies.length && enemies.every(e=>!e.alive) && player.hp>0){
    showUpgradeOverlay();
  }

  timeSinceHit+=dt;
}

// =========================================================
// Render
// =========================================================
function render(dt){
  const W=canvas.width, H=canvas.height, B=settings.brightness;
  // Sky & floor (bright synthwave)
  const sky=ctx.createLinearGradient(0,0,0,H/2);
  sky.addColorStop(0,shade('#6d83ff',B)); sky.addColorStop(1,shade('#2b2f73',B));
  ctx.fillStyle=sky; ctx.fillRect(0,0,W,H/2);
  const floor=ctx.createLinearGradient(0,H/2,0,H);
  floor.addColorStop(0,shade('#2c3555',B)); floor.addColorStop(1,shade('#0b0f1f',B));
  ctx.fillStyle=floor; ctx.fillRect(0,H/2,W,H/2);

  // Ray-cast walls (camera height uses player.z)
  if(zbuf.length!==W) zbuf=new Float32Array(W);
  for(let x=0;x<W;x++){
    const cameraX=(2*x/W - 1);
    const rayAng=player.a + cameraX * player.fov/2 * 2;
    const hit=castRay(player.x,player.y,rayAng,60);
    const dist=hit.dist * Math.cos(rayAng-player.a);
    zbuf[x]=dist;
    const lineH = Math.min(H, (H / (dist+0.0001)));
    // vertical shift by jump height
    const y0 = (H - lineH)/2 - player.z*18;

    let col=WALL_COL[hit.tile]||'#888';
    if(hit.side) col=shade(col,0.75);
    col=shade(col,B);
    ctx.fillStyle=col; ctx.fillRect(x,y0,1,lineH);
  }

  // Enemies (billboards)
  const vis=[];
  for(const e of enemies){
    if(!e.alive) continue;
    const dx=e.x-player.x, dy=e.y-player.y, dist=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx)-player.a;
    let a=((ang+Math.PI*3)%(Math.PI*2))-Math.PI;
    if(Math.abs(a)<player.fov*0.7 && dist>0.2) vis.push({e,dist,a});
  }
  vis.sort((a,b)=>b.dist-a.dist);
  for(const v of vis){
    const color = ENEMY_TYPES[v.e.type].color;
    const size = Math.min(H, H/(v.dist));
    const sx = ((v.a/(player.fov))*(W/2))+W/2;
    const x0=(sx-size/2)|0, x1=(sx+size/2)|0;
    ctx.fillStyle=shade(color, settings.brightness);
    for(let x=Math.max(0,x0); x<Math.min(W,x1); x++){
      if(v.dist<zbuf[x]-0.01){
        ctx.fillRect(x, (H/2 - size*0.95) - player.z*18, 1, size*0.95*2);
      }
    }
    // HP bar
    const maxHp=ENEMY_TYPES[v.e.type].baseHp + Math.floor((round-1)/3);
    const r=Math.max(0,v.e.hp)/maxHp;
    const bw=Math.max(12,size*0.32);
    ctx.fillStyle='#000';
    ctx.fillRect(sx-bw/2, (H/2 - size*0.98) - player.z*18 - 8, bw, 6);
    ctx.fillStyle='#2fff86';
    ctx.fillRect(sx-bw/2, (H/2 - size*0.98) - player.z*18 - 8, bw*r, 6);
  }

  // Projectiles
  ctx.fillStyle=shade('#80c8ff',B);
  for(const p of projectiles){
    const dx=p.x-player.x, dy=p.y-player.y;
    const dist=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx)-player.a;
    let a=((ang+Math.PI*3)%(Math.PI*2))-Math.PI;
    if(Math.abs(a)<player.fov*0.75){
      const size=Math.min(6, 120/(dist+0.1));
      const sx=((a/(player.fov))*(W/2))+W/2;
      ctx.fillRect(sx-size/2, H/2 - player.z*18, size, size);
    }
  }

  // Crosshair
  ctx.strokeStyle=shade('#ffffff',B);
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(W/2-8,H/2 - player.z*18); ctx.lineTo(W/2+8,H/2 - player.z*18);
  ctx.moveTo(W/2,H/2-8 - player.z*18); ctx.lineTo(W/2,H/2+8 - player.z*18);
  ctx.stroke();

  // Muzzle flash
  if(flashTimer>0){ ctx.fillStyle='rgba(255,245,200,0.16)'; ctx.fillRect(0,0,W,H); flashTimer-=dt; }

  // Mini-map
  const cell=6, off=10;
  ctx.fillStyle='#0009'; ctx.fillRect(off-2,off-2,MAP_W*cell+4,MAP_H*cell+4);
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      const t=map[idx(x,y)];
      let c = t? '#39415f' : '#14182a';
      if(t===2) c='#5b3a16';
      if(t===3) c='#2f6b1a';
      if(t===4) c='#0a0e1c';
      ctx.fillStyle=shade(c,settings.brightness);
      ctx.fillRect(off+x*cell, off+y*cell, cell-1, cell-1);
    }
  }
  // player
  ctx.fillStyle='#7de1ff';
  const px=off+player.x*cell, py=off+player.y*cell;
  ctx.beginPath(); ctx.arc(px,py,2,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#7de1ff'; ctx.beginPath();
  ctx.moveTo(px,py); ctx.lineTo(px+Math.cos(player.a)*8, py+Math.sin(player.a)*8); ctx.stroke();
  // enemies
  for(const e of enemies){
    ctx.fillStyle = e.alive ? ENEMY_TYPES[e.type].color : '#666';
    ctx.fillRect(off+e.x*cell-1, off+e.y*cell-1, 3,3);
  }

  // HUD boxes
  ctx.textBaseline='top'; ctx.textAlign='left'; ctx.font='bold 16px system-ui,Arial';
  // Round (top-right)
  const rw=180, rh=52, pad=10;
  ctx.fillStyle='#0009'; ctx.fillRect(W-rw-pad, pad, rw, rh);
  ctx.fillStyle='#fff';
  ctx.fillText(`Round: ${round}`, W-rw+8-pad, pad+6);
  ctx.fillText(`Kills: ${kills}`,  W-rw+8-pad, pad+26);

  // Ammo / HP (bottom-left)
  const bw=260,bh=60;
  ctx.fillStyle='#0009'; ctx.fillRect(pad,H-bh-pad,bw,bh);
  ctx.fillStyle='#fff';
  ctx.fillText(`HP: ${Math.ceil(player.hp)}/${player.maxHp}`, pad+8, H-bh+6-pad);
  ctx.fillText(`Ammo: ${weapon.ammoInMag}/${weapon.magSize}  •  Res: ${weapon.reserve}`, pad+8, H-bh+28-pad);
  if(weapon.reloading>0){
    ctx.fillText(`Reloading...`, pad+8, H-bh+46-pad);
  }
}

// =========================================================
// Main loop
// =========================================================
function loop(ts){
  const dt=Math.min(0.033,(ts-last)/1000); last=ts;
  if(!showingOverlay && player.hp>0){
    update(dt);
  }
  render(dt);
  requestAnimationFrame(loop);
}

// Helpers
function q(sel){ return document.querySelector(sel); }
function norm(v){ const m=Math.hypot(v.x,v.y)||1; return {x:v.x/m,y:v.y/m}; }

// Start
function startGame(){
  spawnRound();
  showToast('Clear waves. Jump crates, avoid pits. Pick an upgrade each round.');
  requestAnimationFrame(loop);
}
startGame();
})();
</script>
</body>
</html>
