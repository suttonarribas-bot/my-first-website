<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Retro Arena — Menus + Settings (GitHub Pages Ready)</title>
<style>
  html,body{margin:0;height:100%;background:#0a0c12;color:#eee;font-family:system-ui,Arial}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:8px}
  canvas{width:100vw;max-width:1000px;height:60vh;background:#000;touch-action:none;cursor:crosshair}
  .hud{max-width:1000px;width:100%;display:flex;flex-wrap:wrap;gap:10px;align-items:center;font-size:14px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{padding:.5rem .8rem;border:1px solid #666;background:#1f2330;color:#eee;border-radius:8px;cursor:pointer}
  .slider{display:flex;gap:8px;align-items:center}
  .slider input{width:170px;height:30px}
  .value{min-width:44px;text-align:right}
  .spacer{flex:1}

  /* Touch zones */
  .zones{position:fixed;inset:0;pointer-events:none}
  .zone{position:absolute;top:0;height:100%;width:50%;pointer-events:auto}
  .left{left:0}.right{right:0}

  /* Overlays */
  .toast{position:fixed;top:8px;left:50%;transform:translateX(-50%);background:#1f2330;padding:.5rem .8rem;border:1px solid #555;border-radius:8px;opacity:.95;z-index:40;display:none}
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,.66);display:none;align-items:center;justify-content:center;padding:16px;z-index:30}
  .panel{background:#141824;border:1px solid #41465a;border-radius:12px;padding:16px;max-width:980px;width:95%;box-shadow:0 8px 32px rgba(0,0,0,.5)}
  .panel h1,.panel h2{margin:0 0 8px 0}
  .choices{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin-top:10px}
  .choice{border:1px solid #4a516a;background:#192035;border-radius:10px;padding:12px;cursor:pointer}
  .choice:hover{background:#202742}
  .meta{opacity:.85;font-size:13px}
  .tree{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .tag{background:#26304b;border:1px solid #445079;padding:.18rem .45rem;border-radius:999px;font-size:12px}

  .menu-grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .menu-card{border:1px solid #444;background:#1a2030;border-radius:12px;padding:12px}
  .menu-actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  .help{max-width:1000px;width:100%;opacity:.9;font-size:13px}
  .kbd{display:inline-block;border:1px solid #5b637d;background:#20273a;border-radius:6px;padding:0 .4rem;margin:0 .1rem}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1000" height="600" aria-label="Arena view"></canvas>

  <div class="hud" role="group" aria-label="Controls">
    <div class="row">
      <button id="fireBtn"   class="btn" title="Left click / tap">Fire</button>
      <button id="jumpBtn"   class="btn" title="Space / double-tap right">Jump</button>
      <button id="reloadBtn" class="btn" title="R">Reload</button>
      <button id="pauseBtn"  class="btn" title="Esc">Pause</button>
      <button id="fsBtn"     class="btn" title="Fullscreen">Fullscreen</button>
      <button id="musicBtn"  class="btn" title="Toggle music">Music: Off</button>
      <button id="sfxBtn"    class="btn" title="Toggle SFX">SFX: On</button>
      <button id="lockBtn"   class="btn" title="Pointer lock (desktop)">Mouse Look</button>
    </div>
    <div class="spacer"></div>
    <div class="row" role="group" aria-label="Quick Settings">
      <div class="slider">
        <label for="fov">FOV</label>
        <input id="fov" type="range" min="55" max="110" step="1" value="85"><span id="fovVal" class="value">85°</span>
      </div>
      <div class="slider">
        <label for="sens">Sensitivity</label>
        <input id="sens" type="range" min="60" max="300" step="1" value="150"><span id="sensVal" class="value">1.50</span>
      </div>
      <div class="slider">
        <label for="bright">Brightness</label>
        <input id="bright" type="range" min="90" max="180" step="1" value="145"><span id="brightVal" class="value">1.45</span>
      </div>
    </div>
    <div class="help">Desktop: <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> move, mouse or <span class="kbd">←</span><span class="kbd">→</span> look, click to fire, <span class="kbd">Space</span> jump, <span class="kbd">R</span> reload, <span class="kbd">L</span> lock mouse, <span class="kbd">Esc</span> pause. Phone: drag left to move, drag right to look, tap right to fire, double-tap right to jump.</div>
  </div>
</div>

<!-- Touch zones -->
<div class="zones" aria-hidden="true">
  <div id="zoneLeft"  class="zone left"></div>
  <div id="zoneRight" class="zone right"></div>
</div>

<!-- Start Menu -->
<div id="startOverlay" class="overlay" style="display:flex">
  <div class="panel">
    <h1>Retro Arena</h1>
    <div class="menu-grid">
      <div class="menu-card">
        <h2>Quick Start</h2>
        <p>Clear waves of monsters. Pick an upgrade after each round. Hop crates, avoid pits, survive.</p>
        <ul>
          <li>Click <strong>Start Game</strong> or press any fire button.</li>
          <li><strong>Space</strong> jumps. <strong>R</strong> reloads.</li>
          <li>Upgrades appear between rounds.</li>
        </ul>
      </div>
      <div class="menu-card">
        <h2>Settings</h2>
        <div class="slider"><label for="fov_s">FOV</label><input id="fov_s" type="range" min="55" max="110" step="1"><span id="fov_s_val" class="value"></span></div>
        <div class="slider"><label for="sens_s">Sensitivity</label><input id="sens_s" type="range" min="60" max="300" step="1"><span id="sens_s_val" class="value"></span></div>
        <div class="slider"><label for="bright_s">Brightness</label><input id="bright_s" type="range" min="90" max="180" step="1"><span id="bright_s_val" class="value"></span></div>
        <div class="menu-actions">
          <button id="music_s" class="btn">Music: Off</button>
          <button id="sfx_s"   class="btn">SFX: On</button>
          <button id="fs_s"    class="btn">Fullscreen</button>
        </div>
      </div>
    </div>
    <div class="menu-actions">
      <button id="startBtn" class="btn">Start Game</button>
      <button id="quickStartBtn" class="btn">Quick Start</button>
    </div>
  </div>
</div>

<!-- Pause Menu -->
<div id="pauseOverlay" class="overlay">
  <div class="panel">
    <h2>Paused</h2>
    <div class="menu-grid">
      <div class="menu-card">
        <h3>Controls</h3>
        <p><span class="kbd">WASD</span> move, mouse or <span class="kbd">←</span><span class="kbd">→</span> look, click fire, <span class="kbd">Space</span> jump, <span class="kbd">R</span> reload, <span class="kbd">L</span> lock mouse, <span class="kbd">Esc</span> pause.</p>
        <p>Phone: drag left to move, drag right to look, tap right to fire, double-tap right to jump.</p>
      </div>
      <div class="menu-card">
        <h3>Settings</h3>
        <div class="slider"><label for="fov_p">FOV</label><input id="fov_p" type="range" min="55" max="110" step="1"><span id="fov_p_val" class="value"></span></div>
        <div class="slider"><label for="sens_p">Sensitivity</label><input id="sens_p" type="range" min="60" max="300" step="1"><span id="sens_p_val" class="value"></span></div>
        <div class="slider"><label for="bright_p">Brightness</label><input id="bright_p" type="range" min="90" max="180" step="1"><span id="bright_p_val" class="value"></span></div>
        <div class="menu-actions">
          <button id="music_p" class="btn">Music: Off</button>
          <button id="sfx_p"   class="btn">SFX: On</button>
          <button id="fs_p"    class="btn">Fullscreen</button>
        </div>
      </div>
    </div>
    <div class="menu-actions">
      <button id="resumeBtn"  class="btn">Resume</button>
      <button id="restartBtn" class="btn">Restart Round</button>
      <button id="quitBtn"    class="btn">Quit to Title</button>
    </div>
  </div>
</div>

<!-- Upgrade Overlay -->
<div id="upgradeOverlay" class="overlay" role="dialog" aria-modal="true">
  <div class="panel">
    <h2 id="overlayTitle">Round Cleared</h2>
    <div class="meta" id="overlayMeta"></div>
    <div style="margin-top:10px">Pick one upgrade:</div>
    <div class="choices" id="choices"></div>
    <div style="margin-top:10px">
      <div class="meta">Press 1 / 2 / 3 to choose quickly</div>
      <div class="tree" id="tree"></div>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
(()=>{
// ---------- Safe query helpers ----------
const $ = (sel) => document.querySelector(sel);
const req = (sel) => {
  const el = $(sel);
  if(!el){ console.error('Missing element:', sel); throw new Error('Missing element '+sel); }
  return el;
};

// ---------- Canvas & ctx ----------
const canvas = req('#game');
const ctx = canvas.getContext('2d');

// ---------- Settings (persisted) ----------
const getNum = (k,d)=>{const v=localStorage.getItem(k); return v?+v:d;};
const setNum = (k,v)=>localStorage.setItem(k,v);
const settings = {
  fovDeg: getNum('arena_fov', 85),
  sensitivity: getNum('arena_sens', 1.5),
  brightness: getNum('arena_bright', 1.45),
  sfx: !!getNum('arena_sfx', 1),
  music: !!getNum('arena_music', 0),
};
function saveSettings(){
  setNum('arena_fov', settings.fovDeg);
  setNum('arena_sens', settings.sensitivity);
  setNum('arena_bright', settings.brightness);
  setNum('arena_sfx', settings.sfx?1:0);
  setNum('arena_music', settings.music?1:0);
}

// ---------- UI: Toast ----------
const toast = req('#toast');
function showToast(msg, ms=1200){
  toast.textContent = msg;
  toast.style.display = 'block';
  clearTimeout(toast._to);
  toast._to = setTimeout(()=>toast.style.display='none', ms);
}

// ---------- Colors & utils ----------
function shade(hex,f){const c=parseInt(hex.slice(1),16);let r=((c>>16)&255)*f|0,g=((c>>8)&255)*f|0,b=(c&255)*f|0; r=Math.min(255,Math.max(0,r)); g=Math.min(255,Math.max(0,g)); b=Math.min(255,Math.max(0,b)); return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);}
function norm(v){ const m=Math.hypot(v.x,v.y)||1; return {x:v.x/m,y:v.y/m}; }

// ---------- World (bright arena) ----------
const MAP_W=28, MAP_H=24;
const map = new Array(MAP_W*MAP_H).fill(0);
const idx=(x,y)=>y*MAP_W+x;
for(let x=0;x<MAP_W;x++){ map[idx(x,0)]=1; map[idx(x,MAP_H-1)]=1; }
for(let y=0;y<MAP_H;y++){ map[idx(0,y)]=1; map[idx(MAP_W-1,y)]=1; }
const pillars=[[6,6],[6,17],[12,12],[20,6],[20,17],[14,5],[14,18]];
for(const [px,py] of pillars){ for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) map[idx(px+dx,py+dy)]=2; }
const crates=[[9,8],[10,8],[11,8],[16,10],[16,11],[16,12],[7,15],[8,15],[9,15]];
for(const [x,y] of crates) map[idx(x,y)]=3;
const pits=[[4,11],[5,11],[6,11],[7,11],[8,11],[19,14],[20,14],[21,14]];
for(const [x,y] of pits) map[idx(x,y)]=4;
const WALL_COL={1:'#7bd3ff',2:'#ffb36b',3:'#9be070',4:'#303848'};
function tile(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return 1; return map[(y|0)*MAP_W+(x|0)]; }

// ---------- Player / weapon ----------
let zbuf = new Float32Array(canvas.width);
let last = performance.now();
let flashTimer=0, timeSinceHit=0;

const player = {x:5.5,y:5.5,a:0,fov:settings.fovDeg*Math.PI/180,speed:6.4,rot:2.6,hp:110,maxHp:110,vz:0,z:0,grounded:true};
const weapon = {damage:1,fireRate:3,pierce:0,cooldown:0,critMult:2,magSize:10,ammoInMag:10,reserve:90,reloadTime:1.3,reloading:0};

// ---------- Rounds & enemies ----------
let round=1, kills=0, enemies=[], projectiles=[];
const ENEMY_TYPES = {
  melee:{name:'Melee', baseHp:1,color:'#ff5e66',speed:1.25,touchDmg:9, range:0,  rof:0},
  fast: {name:'Runner',baseHp:1,color:'#59ff9c',speed:1.85,touchDmg:7, range:0,  rof:0},
  tank: {name:'Tank',  baseHp:4,color:'#b071ff',speed:0.95,touchDmg:14,range:0,  rof:0},
  ranged:{name:'Ranger',baseHp:2,color:'#5ec5ff',speed:1.2,touchDmg:5, range:14, rof:0.6},
};
let regenActive=false;

function randSpawn(){
  for(let t=0;t<300;t++){
    const x=2+Math.random()*(MAP_W-4), y=2+Math.random()*(MAP_H-4);
    const tt = tile(x,y);
    if((tt===0 || tt===4) && Math.hypot(x-player.x,y-player.y)>7) return {x,y};
  }
  return {x:MAP_W-3,y:MAP_H-3};
}
function pickEnemyType(r){
  const roll=Math.random();
  const rR=Math.min(0.35,0.12+r*0.02), tR=Math.min(0.30,0.08+r*0.02), fR=Math.min(0.35,0.12+r*0.02);
  if(roll<rR) return 'ranged'; if(roll<rR+fR) return 'fast'; if(roll<rR+fR+tR) return 'tank'; return 'melee';
}
function spawnRound(){
  enemies.length=0; projectiles.length=0;
  const count=Math.min(8+round*2,80);
  for(let i=0;i<count;i++){
    const pos=randSpawn(), type=pickEnemyType(round), t=ENEMY_TYPES[type];
    enemies.push({type, x:pos.x,y:pos.y, alive:true, hp:t.baseHp+Math.floor((round-1)/3), speed:t.speed+Math.min(0.8,(round-1)*0.05), touchDmg:t.touchDmg+Math.floor(round*0.3), fireTimer:0});
  }
}

// ---------- Input ----------
const keys = {};
const keyBlock = new Set(['Space','KeyR','KeyL','Escape','ArrowLeft','ArrowRight','ArrowUp','ArrowDown','KeyW','KeyA','KeyS','KeyD','Digit1','Digit2','Digit3']);
addEventListener('keydown', e=>{
  keys[e.code]=true;
  if(keyBlock.has(e.code)) e.preventDefault();
  if(e.code==='Escape') togglePause(true);
  if(e.code==='KeyR') reload();
  if(e.code==='Space') jump();
  if(showingUpgrade){
    if(e.code==='Digit1') pickUpgrade(0);
    if(e.code==='Digit2') pickUpgrade(1);
    if(e.code==='Digit3') pickUpgrade(2);
  }
});
addEventListener('keyup', e=>{ keys[e.code]=false; if(keyBlock.has(e.code)) e.preventDefault(); });

// Pointer lock (needs https — GitHub Pages is https)
let pointerLocked=false;
req('#lockBtn').onclick = togglePointerLock;
canvas.addEventListener('click', e=>{
  if(!showingStart && !showingPause && !showingUpgrade){
    if(!pointerLocked) togglePointerLock();
    fire();
  }
});
function togglePointerLock(){
  if(document.pointerLockElement===canvas){ document.exitPointerLock(); }
  else { canvas.requestPointerLock(); }
}
document.addEventListener('pointerlockchange', ()=>{ pointerLocked = (document.pointerLockElement===canvas); });
document.addEventListener('mousemove', e=>{
  if(pointerLocked && !showingStart && !showingPause && !showingUpgrade){
    player.a += (e.movementX||0)*0.0025*settings.sensitivity;
  }
});

// Touch zones
const leftZone = req('#zoneLeft'), rightZone = req('#zoneRight');
let moveTouch=null, lookTouch=null, moveVec={x:0,y:0}, lookDX=0, lastTap=0;
function bindZone(el,start,move,end){
  el.addEventListener('pointerdown', e=>{ el.setPointerCapture(e.pointerId); start(e); });
  el.addEventListener('pointermove', e=>move(e));
  el.addEventListener('pointerup', e=>end(e));
  el.addEventListener('pointercancel', e=>end(e));
}
bindZone(leftZone,
  e=>{ if(moveTouch) return; moveTouch=e.pointerId; moveVec={x:0,y:0}; },
  e=>{ if(e.pointerId!==moveTouch) return; const r=leftZone.getBoundingClientRect(); const cx=r.left+r.width/2, cy=r.top+r.height/2; moveVec={x:(e.clientX-cx)/r.width*2, y:(e.clientY-cy)/r.height*2}; },
  e=>{ if(e.pointerId===moveTouch){ moveTouch=null; moveVec={x:0,y:0}; } }
);
bindZone(rightZone,
  e=>{ if(lookTouch) return; lookTouch=e.pointerId; rightZone._lastX=e.clientX; const now=performance.now(); if(now-lastTap<250) jump(); lastTap=now; },
  e=>{ if(e.pointerId!==lookTouch) return; const dx=e.clientX-rightZone._lastX; rightZone._lastX=e.clientX; lookDX+=dx; },
  e=>{ if(e.pointerId===lookTouch){ fire(); lookTouch=null; } }
);

// Buttons (all guarded with req())
req('#fireBtn').onclick   = ()=>fire();
req('#jumpBtn').onclick   = ()=>jump();
req('#reloadBtn').onclick = ()=>reload();
req('#pauseBtn').onclick  = ()=>togglePause(true);
req('#fsBtn').onclick     = ()=>{ if(!document.fullscreenElement){ (document.body.requestFullscreen||document.documentElement.requestFullscreen||canvas.requestFullscreen).call(document.body); } else document.exitFullscreen&&document.exitFullscreen(); };

// HUD sliders
wireSlider('#fov','#fovVal',v=>{settings.fovDeg=+v; player.fov=settings.fovDeg*Math.PI/180; saveSettings();},v=>`${v}°`,settings.fovDeg);
wireSlider('#sens','#sensVal',v=>{settings.sensitivity=(+v)/100; saveSettings();},v=>(+v/100).toFixed(2),Math.round(settings.sensitivity*100));
wireSlider('#bright','#brightVal',v=>{settings.brightness=(+v)/100; saveSettings();},v=>(+v/100).toFixed(2),Math.round(settings.brightness*100));

// Music/SFX buttons (HUD & menus share these handlers)
req('#musicBtn').onclick = ()=>{ settings.music=!settings.music; saveSettings(); updateMusicLabels(); if(settings.music) startMusic(); else stopMusic(); };
req('#sfxBtn').onclick   = ()=>{ settings.sfx=!settings.sfx; saveSettings(); updateSfxLabels(); };

function updateMusicLabels(){
  const text = 'Music: ' + (settings.music?'On':'Off');
  ['#musicBtn','#music_s','#music_p'].forEach(sel=>{ const b=$(sel); if(b) b.textContent=text; });
}
function updateSfxLabels(){
  const text = 'SFX: ' + (settings.sfx?'On':'Off');
  ['#sfxBtn','#sfx_s','#sfx_p'].forEach(sel=>{ const b=$(sel); if(b) b.textContent=text; });
}

// ---------- Start & Pause Menus ----------
const startOverlay = req('#startOverlay');
const pauseOverlay = req('#pauseOverlay');
let showingStart = true, showingPause=false, showingUpgrade=false;

// Start menu buttons
req('#startBtn').onclick = startFromMenu;
req('#quickStartBtn').onclick = startFromMenu;
function startFromMenu(){
  startOverlay.style.display='none';
  showingStart=false;
  hardReset();
  spawnRound();
  // Prime AudioContext on user gesture for mobile Safari
  AC();
}

// Pause menu wiring
req('#resumeBtn').onclick  = ()=>togglePause(false);
req('#restartBtn').onclick = ()=>{ togglePause(false); restartRound(); };
req('#quitBtn').onclick    = ()=>{ togglePause(false); pointerUnlock(); toTitle(); };

function togglePause(show){
  if(showingUpgrade || showingStart) return;
  showingPause = show ?? !showingPause;
  pauseOverlay.style.display = showingPause ? 'flex' : 'none';
  if(showingPause) pointerUnlock();
}
function pointerUnlock(){ if(document.pointerLockElement===canvas){ document.exitPointerLock(); }}

// Sync sliders inside Start and Pause menus
function wireMenuSliders(prefix){
  const F = req(`#${prefix}fov`), FV = req(`#${prefix}fov_val`);
  const S = req(`#${prefix}sens`), SV = req(`#${prefix}sens_val`);
  const B = req(`#${prefix}bright`), BV = req(`#${prefix}bright_val`);
  F.value = settings.fovDeg;      FV.textContent = settings.fovDeg+'°';
  S.value = Math.round(settings.sensitivity*100); SV.textContent = settings.sensitivity.toFixed(2);
  B.value = Math.round(settings.brightness*100);  BV.textContent = settings.brightness.toFixed(2);
  F.oninput = ()=>{ settings.fovDeg=+F.value; FV.textContent=settings.fovDeg+'°'; player.fov=settings.fovDeg*Math.PI/180; saveSettings(); syncHudSliders(); };
  S.oninput = ()=>{ settings.sensitivity=(+S.value)/100; SV.textContent=settings.sensitivity.toFixed(2); saveSettings(); syncHudSliders(); };
  B.oninput = ()=>{ settings.brightness=(+B.value)/100;  BV.textContent=settings.brightness.toFixed(2); saveSettings(); syncHudSliders(); };
  const MB = req(`#${prefix}music`), SB=req(`#${prefix}sfx`), FB=req(`#${prefix}fs`);
  MB.textContent = 'Music: '+(settings.music?'On':'Off');
  SB.textContent = 'SFX: '+(settings.sfx?'On':'Off');
  MB.onclick=()=>{ settings.music=!settings.music; saveSettings(); updateMusicLabels(); if(settings.music) startMusic(); else stopMusic(); };
  SB.onclick=()=>{ settings.sfx=!settings.sfx; saveSettings(); updateSfxLabels(); };
  if(FB){ FB.onclick = ()=>{ if(!document.fullscreenElement){ (document.body.requestFullscreen||document.documentElement.requestFullscreen||canvas.requestFullscreen).call(document.body); } else document.exitFullscreen&&document.exitFullscreen(); }; }
}
function syncHudSliders(){
  const f=req('#fov'), fv=req('#fovVal'), s=req('#sens'), sv=req('#sensVal'), b=req('#bright'), bv=req('#brightVal');
  if(f){ f.value = settings.fovDeg; fv.textContent=settings.fovDeg+'°'; }
  if(s){ s.value = Math.round(settings.sensitivity*100); sv.textContent=settings.sensitivity.toFixed(2); }
  if(b){ b.value = Math.round(settings.brightness*100); bv.textContent=settings.brightness.toFixed(2); }
}

// Start menu slider wiring
wireMenuSliders('fov_' /*dummy*/); // no-op guard
(function(){
  // explicit start menu IDs
  const F='#fov_s', FV='#fov_s_val', S='#sens_s', SV='#sens_s_val', B='#bright_s', BV='#bright_s_val';
  $(F).value = settings.fovDeg; $(FV).textContent = settings.fovDeg+'°';
  $(S).value = Math.round(settings.sensitivity*100); $(SV).textContent = settings.sensitivity.toFixed(2);
  $(B).value = Math.round(settings.brightness*100);  $(BV).textContent = settings.brightness.toFixed(2);
  $(F).oninput = ()=>{ settings.fovDeg=+$(F).value; $(FV).textContent=settings.fovDeg+'°'; player.fov=settings.fovDeg*Math.PI/180; saveSettings(); syncHudSliders(); };
  $(S).oninput = ()=>{ settings.sensitivity=(+$(S).value)/100; $(SV).textContent=settings.sensitivity.toFixed(2); saveSettings(); syncHudSliders(); };
  $(B).oninput = ()=>{ settings.brightness=(+$(B).value)/100;  $(BV).textContent=settings.brightness.toFixed(2); saveSettings(); syncHudSliders(); };
  req('#music_s').textContent = 'Music: '+(settings.music?'On':'Off');
  req('#sfx_s').textContent   = 'SFX: '+(settings.sfx?'On':'Off');
  req('#fs_s').onclick = ()=>{ if(!document.fullscreenElement){ (document.body.requestFullscreen||document.documentElement.requestFullscreen||canvas.requestFullscreen).call(document.body); } else document.exitFullscreen&&document.exitFullscreen(); };
})();

// Pause menu slider wiring
(function(){
  const F='#fov_p', FV='#fov_p_val', S='#sens_p', SV='#sens_p_val', B='#bright_p', BV='#bright_p_val';
  $(F).value = settings.fovDeg; $(FV).textContent = settings.fovDeg+'°';
  $(S).value = Math.round(settings.sensitivity*100); $(SV).textContent = settings.sensitivity.toFixed(2);
  $(B).value = Math.round(settings.brightness*100);  $(BV).textContent = settings.brightness.toFixed(2);
  $(F).oninput = ()=>{ settings.fovDeg=+$(F).value; $(FV).textContent=settings.fovDeg+'°'; player.fov=settings.fovDeg*Math.PI/180; saveSettings(); syncHudSliders(); };
  $(S).oninput = ()=>{ settings.sensitivity=(+$(S).value)/100; $(SV).textContent=settings.sensitivity.toFixed(2); saveSettings(); syncHudSliders(); };
  $(B).oninput = ()=>{ settings.brightness=(+$(B).value)/100;  $(BV).textContent=settings.brightness.toFixed(2); saveSettings(); syncHudSliders(); };
  req('#music_p').textContent = 'Music: '+(settings.music?'On':'Off');
  req('#sfx_p').textContent   = 'SFX: '+(settings.sfx?'On':'Off');
  req('#fs_p').onclick = ()=>{ if(!document.fullscreenElement){ (document.body.requestFullscreen||document.documentElement.requestFullscreen||canvas.requestFullscreen).call(document.body); } else document.exitFullscreen&&document.exitFullscreen(); };
})();

// HUD music/sfx initial labels
updateMusicLabels(); updateSfxLabels();

// ---------- Audio (WebAudio; user-gesture safe) ----------
let ac=null, musicOsc=null;
function AC(){
  if(!ac){
    const C = window.AudioContext||window.webkitAudioContext;
    ac = C ? new C() : null;
  }
  // resume if suspended on iOS/Safari after user interaction
  if(ac && ac.state==='suspended'){ ac.resume(); }
  return ac;
}
function sfx(freq=600,dur=0.06,type='square',vol=0.15){
  if(!settings.sfx) return;
  const a=AC(); if(!a) return;
  const o=a.createOscillator(), g=a.createGain();
  o.type=type; o.frequency.value=freq;
  g.gain.value=vol;
  o.connect(g); g.connect(a.destination);
  const t=a.currentTime; o.start(t); o.stop(t+dur);
  g.gain.setValueAtTime(vol,t); g.gain.exponentialRampToValueAtTime(0.001,t+dur);
}
function startMusic(){
  if(!settings.music) return;
  const a=AC(); if(!a) return;
  stopMusic();
  musicOsc=a.createOscillator();
  const g=a.createGain(); g.gain.value=0.06;
  musicOsc.type='triangle'; musicOsc.frequency.value=140;
  const lfo=a.createOscillator(), lg=a.createGain(); lfo.frequency.value=0.5; lg.gain.value=40; lfo.connect(lg); lg.connect(musicOsc.frequency);
  musicOsc.connect(g); g.connect(a.destination);
  const t=a.currentTime; musicOsc.start(t); lfo.start(t);
}
function stopMusic(){ if(musicOsc){ try{musicOsc.stop();}catch{} musicOsc=null; } }

// ---------- Resize / DPR ----------
function fitCanvas(){
  const dpr=Math.min(2, window.devicePixelRatio||1);
  const cssW=Math.min(window.innerWidth,1000);
  const cssH=Math.floor(cssW*0.6);
  canvas.style.width=cssW+'px';
  canvas.style.height=cssH+'px';
  canvas.width=Math.floor(cssW*dpr);
  canvas.height=Math.floor(cssH*dpr);
  zbuf = new Float32Array(canvas.width);
}
fitCanvas();
addEventListener('resize', fitCanvas);

// ---------- Raycast / movement ----------
function castRay(ax,ay,ang,max=60){
  const sin=Math.sin(ang), cos=Math.cos(ang);
  let dist=0, hit=false, side=0, hitTile=0;
  let mapX=Math.floor(ax), mapY=Math.floor(ay);
  const dX=Math.abs(1/(cos||1e-6)), dY=Math.abs(1/(sin||1e-6));
  let stepX=(cos<0)?-1:1, stepY=(sin<0)?-1:1;
  let sX=(cos<0)?(ax-mapX)*dX:(mapX+1-ax)*dX;
  let sY=(sin<0)?(ay-mapY)*dY:(mapY+1-ay)*dY;
  while(!hit && dist<max){
    if(sX<sY){ sX+=dX; mapX+=stepX; side=0; }
    else { sY+=dY; mapY+=stepY; side=1; }
    hitTile = tile(mapX,mapY);
    if(hitTile!==0){ hit=true; dist=(side===0)?(sX-dX):(sY-dY); }
  }
  return {dist:dist||max, side, tile:hitTile};
}
function tryMove(obj,vx,vy,canHop=false){
  const pad=0.2; let nx=obj.x+vx, ny=obj.y+vy;
  const hop = canHop && player.z>0.6;
  const tX=tile(nx+Math.sign(vx)*pad,obj.y), tY=tile(obj.x,ny+Math.sign(vy)*pad);
  if(tX===0||tX===4||(tX===3&&hop)) obj.x=nx;
  if(tY===0||tY===4||(tY===3&&hop)) obj.y=ny;
}

// ---------- Combat / AI ----------
function reload(){
  if(weapon.reloading>0) return;
  if(weapon.ammoInMag>=weapon.magSize) return;
  if(weapon.reserve<=0){ showToast('No reserve'); sfx(200,0.08,'sawtooth',0.08); return; }
  weapon.reloading = weapon.reloadTime;
  sfx(300,0.12,'triangle',0.12);
}
function jump(){ if(player.grounded){ player.vz=5; player.grounded=false; sfx(220,0.06,'square',0.06);} }
function fire(){
  if(showingStart || showingPause || showingUpgrade) return;
  if(weapon.reloading>0 || weapon.cooldown>0) return;
  if(weapon.ammoInMag<=0){ sfx(120,0.06,'square',0.08); reload(); return; }
  weapon.cooldown = 1/weapon.fireRate; weapon.ammoInMag--; flashTimer=0.06; sfx(800,0.05,'square',0.12);

  // hitscan
  const cands=[];
  for(let i=0;i<enemies.length;i++){
    const e=enemies[i]; if(!e.alive) continue;
    const dx=e.x-player.x, dy=e.y-player.y, dist=Math.hypot(dx,dy);
    const angTo=Math.atan2(dy,dx); let da=((angTo-player.a+Math.PI*3)%(Math.PI*2))-Math.PI;
    if(Math.abs(da)<player.fov*0.06 && dist<24){
      const ray=castRay(player.x,player.y,player.a,60);
      if(ray.dist+0.05>=dist) cands.push({i,dist,da});
    }
  }
  cands.sort((a,b)=>a.dist-b.dist);
  let pier=weapon.pierce, hit=false;
  for(const c of cands){
    const e=enemies[c.i]; if(!e.alive) continue;
    const head = Math.abs(c.da) < player.fov*0.02;
    const dmg  = head ? Math.ceil(weapon.damage*2) : weapon.damage;
    e.hp -= dmg; hit=true; if(head) showToast('Headshot!',400);
    if(e.hp<=0){ e.alive=false; kills++; sfx(200,0.05,'triangle',0.1); }
    if(pier<=0) break; pier--;
  }
  if(!hit) showToast('Miss',400);
}

function update(dt){
  // cooldowns & reload
  if(weapon.cooldown>0) weapon.cooldown=Math.max(0,weapon.cooldown-dt);
  if(weapon.reloading>0){
    weapon.reloading=Math.max(0,weapon.reloading-dt);
    if(weapon.reloading===0){
      const need=weapon.magSize-weapon.ammoInMag, take=Math.min(need,weapon.reserve);
      weapon.ammoInMag+=take; weapon.reserve-=take; sfx(500,0.08,'square',0.08);
    }
  }

  // regen
  if(regenActive && timeSinceHit>2 && player.hp>0){
    player.hp=Math.min(player.maxHp, player.hp + 1*dt);
  }

  // input
  const forward=(keys['KeyW']?1:0)-(keys['KeyS']?1:0);
  const strafe =(keys['KeyD']?1:0)-(keys['KeyA']?1:0);
  const turn   =(keys['ArrowRight']?1:0)-(keys['ArrowLeft']?1:0);
  const dirx=Math.cos(player.a), diry=Math.sin(player.a);
  const strx=Math.cos(player.a+Math.PI/2), stry=Math.sin(player.a+Math.PI/2);
  const mv = norm(moveVec);
  const look = lookDX; lookDX=0;

  player.a += turn*player.rot*dt + look*0.004*settings.sensitivity;

  const baseSp=player.speed*dt;
  let vx=dirx*(forward*baseSp)+strx*(strafe*baseSp)+mv.x*baseSp*1.2;
  let vy=diry*(forward*baseSp)+stry*(strafe*baseSp)+mv.y*baseSp*1.2;

  // pit slow
  const under=tile(player.x,player.y); const slow=(under===4 && player.z<0.2)?0.55:1;
  vx*=slow; vy*=slow;

  tryMove(player, vx, vy, true);

  // jump physics
  if(!player.grounded){
    player.vz -= 12*dt;
    player.z += player.vz*dt;
    if(player.z<=0){ player.z=0; player.vz=0; player.grounded=true; }
  }

  // enemies
  for(const e of enemies){
    if(!e.alive) continue;
    const dx=player.x-e.x, dy=player.y-e.y, d=Math.hypot(dx,dy)||1;
    const sp=e.speed*dt;
    tryMove(e,(dx/d)*sp,(dy/d)*sp,false);
    if(d<0.65){ const dmg=e.touchDmg*dt; if(dmg>0){ player.hp=Math.max(0,player.hp-dmg); timeSinceHit=0; } }
    if(e.type==='ranged'){
      e.fireTimer=(e.fireTimer||0)-dt; const T=ENEMY_TYPES.ranged;
      if(d<T.range && e.fireTimer<=0){
        e.fireTimer=1/Math.max(0.2, T.rof+(round*0.02));
        const ang=Math.atan2(dy,dx);
        projectiles.push({x:e.x,y:e.y,vx:Math.cos(ang)*7,vy:Math.sin(ang)*7,color:'#80c8ff',ttl:3,dmg:8});
        sfx(600,0.04,'triangle',0.06);
      }
    }
  }

  // projectiles
  for(const p of projectiles){
    p.ttl-=dt; p.x+=p.vx*dt; p.y+=p.vy*dt;
    const t=tile(p.x,p.y); if(t!==0 && t!==4){ p.ttl=0; continue; }
    const d=Math.hypot(p.x-player.x,p.y-player.y);
    if(d<0.5){ player.hp=Math.max(0,player.hp-p.dmg); p.ttl=0; timeSinceHit=0; sfx(140,0.04,'square',0.08); }
  }
  projectiles=projectiles.filter(p=>p.ttl>0);

  // round clear
  if(enemies.length && enemies.every(e=>!e.alive) && player.hp>0){
    openUpgrade();
  }

  timeSinceHit+=dt;
}

// ---------- Render ----------
function render(dt){
  const W=canvas.width, H=canvas.height, B=settings.brightness;

  // sky/floor
  const sky=ctx.createLinearGradient(0,0,0,H/2);
  sky.addColorStop(0,shade('#6d83ff',B)); sky.addColorStop(1,shade('#2b2f73',B));
  ctx.fillStyle=sky; ctx.fillRect(0,0,W,H/2);
  const floor=ctx.createLinearGradient(0,H/2,0,H);
  floor.addColorStop(0,shade('#2c3555',B)); floor.addColorStop(1,shade('#0b0f1f',B));
  ctx.fillStyle=floor; ctx.fillRect(0,H/2,W,H/2);

  // walls
  if(zbuf.length!==W) zbuf=new Float32Array(W);
  for(let x=0;x<W;x++){
    const cameraX=(2*x/W-1);
    const rayAng=player.a + cameraX * player.fov/2 * 2;
    const hit=castRay(player.x,player.y,rayAng,60);
    const dist=hit.dist*Math.cos(rayAng-player.a);
    zbuf[x]=dist;
    const lineH=Math.min(H, H/(dist+0.0001));
    const y0=(H-lineH)/2 - player.z*18;
    let col=WALL_COL[hit.tile]||'#888';
    if(hit.side) col=shade(col,0.75);
    col=shade(col,B);
    ctx.fillStyle=col;
    ctx.fillRect(x,y0,1,lineH);
  }

  // enemies (billboards)
  const vis=[];
  for(const e of enemies){
    if(!e.alive) continue;
    const dx=e.x-player.x, dy=e.y-player.y, dist=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx)-player.a; let a=((ang+Math.PI*3)%(Math.PI*2))-Math.PI;
    if(Math.abs(a)<player.fov*0.7 && dist>0.2) vis.push({e,dist,a});
  }
  vis.sort((a,b)=>b.dist-a.dist);
  for(const v of vis){
    const color=ENEMY_TYPES[v.e.type].color;
    const size=Math.min(H, H/(v.dist));
    const sx=((v.a/(player.fov))*(W/2))+W/2;
    const x0=(sx-size/2)|0, x1=(sx+size/2)|0;
    ctx.fillStyle=shade(color,B);
    for(let x=Math.max(0,x0); x<Math.min(W,x1); x++){
      if(v.dist<zbuf[x]-0.01){
        ctx.fillRect(x, (H/2 - size*0.95) - player.z*18, 1, size*0.95*2);
      }
    }
    // hp bar
    const maxHp=ENEMY_TYPES[v.e.type].baseHp + Math.floor((round-1)/3);
    const r=Math.max(0,v.e.hp)/maxHp;
    const bw=Math.max(12,size*0.32);
    ctx.fillStyle='#000';
    ctx.fillRect(sx-bw/2,(H/2-size*0.98)-player.z*18-8,bw,6);
    ctx.fillStyle='#2fff86';
    ctx.fillRect(sx-bw/2,(H/2-size*0.98)-player.z*18-8,bw*r,6);
  }

  // enemy bullets
  ctx.fillStyle=shade('#80c8ff',B);
  for(const p of projectiles){
    const dx=p.x-player.x, dy=p.y-player.y, dist=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx)-player.a; let a=((ang+Math.PI*3)%(Math.PI*2))-Math.PI;
    if(Math.abs(a)<player.fov*0.75){
      const size=Math.min(6,120/(dist+0.1));
      const sx=((a/(player.fov))*(W/2))+W/2;
      ctx.fillRect(sx-size/2, H/2 - player.z*18, size, size);
    }
  }

  // crosshair
  ctx.strokeStyle=shade('#ffffff',B);
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(W/2-8, H/2 - player.z*18); ctx.lineTo(W/2+8, H/2 - player.z*18);
  ctx.moveTo(W/2, H/2-8 - player.z*18); ctx.lineTo(W/2, H/2+8 - player.z*18);
  ctx.stroke();

  // flash
  if(flashTimer>0){ ctx.fillStyle='rgba(255,245,200,0.16)'; ctx.fillRect(0,0,W,H); flashTimer-=dt; }

  // minimap & HUD
  const cell=6, off=10;
  ctx.fillStyle='#0009'; ctx.fillRect(off-2,off-2,MAP_W*cell+4,MAP_H*cell+4);
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      const t=map[idx(x,y)];
      let c=t?'#39415f':'#14182a'; if(t===2)c='#5b3a16'; if(t===3)c='#2f6b1a'; if(t===4)c='#0a0e1c';
      ctx.fillStyle=shade(c,settings.brightness);
      ctx.fillRect(off+x*cell, off+y*cell, cell-1, cell-1);
    }
  }
  // player + enemies dots
  ctx.fillStyle='#7de1ff';
  const px=off+player.x*cell, py=off+player.y*cell;
  ctx.beginPath(); ctx.arc(px,py,2,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#7de1ff'; ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px+Math.cos(player.a)*8, py+Math.sin(player.a)*8); ctx.stroke();
  for(const e of enemies){
    ctx.fillStyle = e.alive ? ENEMY_TYPES[e.type].color : '#666';
    ctx.fillRect(off+e.x*cell-1, off+e.y*cell-1, 3,3);
  }

  // round (top-right) + hp/ammo (bottom-left)
  ctx.textBaseline='top'; ctx.textAlign='left'; ctx.font='bold 16px system-ui,Arial';
  const rw=180, rh=52, pad=10;
  ctx.fillStyle='#0009'; ctx.fillRect(W-rw-pad, pad, rw, rh);
  ctx.fillStyle='#fff'; ctx.fillText(`Round: ${round}`, W-rw+8-pad, pad+6); ctx.fillText(`Kills: ${kills}`, W-rw+8-pad, pad+26);
  const bw=260,bh=60;
  ctx.fillStyle='#0009'; ctx.fillRect(pad, H-bh-pad, bw, bh);
  ctx.fillStyle='#fff'; ctx.fillText(`HP: ${Math.ceil(player.hp)}/${player.maxHp}`, pad+8, H-bh+6-pad);
  ctx.fillText(`Ammo: ${weapon.ammoInMag}/${weapon.magSize}  •  Res: ${weapon.reserve}`, pad+8, H-bh+28-pad);
  if(weapon.reloading>0) ctx.fillText(`Reloading...`, pad+8, H-bh+46-pad);

  if(player.hp<=0){
    ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#f55'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font='bold 42px system-ui,Arial'; ctx.fillText('YOU DIED', W/2, H/2-10);
    ctx.font='18px system-ui,Arial'; ctx.fillStyle='#fff'; ctx.fillText(`Rounds survived: ${round-1}  •  Kills: ${kills}`, W/2, H/2+28);
  }
}

// ---------- Upgrades ----------
const upgradeOverlay = req('#upgradeOverlay'), overlayTitle=req('#overlayTitle'), overlayMeta=req('#overlayMeta'), choicesEl=req('#choices'), treeEl=req('#tree');
let upgradeTags=[];
const U = {
  dmg:{name:'+Damage',desc:'+1 weapon damage',apply:()=>weapon.damage+=1},
  rate:{name:'+Fire Rate',desc:'+20% fire rate',apply:()=>weapon.fireRate*=1.2},
  pier:{name:'Pierce +1',desc:'Bullets pierce +1 target',apply:()=>weapon.pierce+=1},
  speed:{name:'Dash Boots',desc:'+12% move speed',apply:()=>player.speed*=1.12},
  hp:{name:'Thicker Skin',desc:'+20 max HP & heal 20',apply:()=>{player.maxHp+=20; player.hp=Math.min(player.maxHp,player.hp+20);}},
  mag:{name:'Bigger Mag',desc:'+30% mag size',apply:()=>{weapon.magSize=Math.max(1,Math.round(weapon.magSize*1.3)); weapon.ammoInMag=weapon.magSize;}},
  stock:{name:'Ammo Stock',desc:'+60 reserve ammo',apply:()=>weapon.reserve+=60},
  crit:{name:'Sharpshot',desc:'Headshots x2.5 dmg',apply:()=>weapon.critMult=2.5},
  regen:{name:'Regenerate',desc:'Heal 1 HP/sec out of combat',apply:()=>regenActive=true},
};
const pool=[U.dmg,U.rate,U.pier,U.speed,U.hp,U.mag,U.stock,U.crit,U.regen];
function randomChoices(n=3){
  const a=[...pool], picks=[];
  for(let i=0;i<n && a.length;i++){ const k=Math.floor(Math.random()*a.length); picks.push(a.splice(k,1)[0]); }
  return picks;
}
let pickUpgrade=()=>{};
function renderTree(){ treeEl.innerHTML=''; upgradeTags.forEach(t=>{ const s=document.createElement('span'); s.className='tag'; s.textContent=t; treeEl.appendChild(s); }); }
function openUpgrade(){
  showingUpgrade=true; upgradeOverlay.style.display='flex';
  overlayTitle.textContent = `Round ${round} cleared`;
  overlayMeta.textContent  = `Kills: ${kills}  •  Weapon: dmg ${weapon.damage}, ROF ${weapon.fireRate.toFixed(2)}/s, pierce ${weapon.pierce}, mag ${weapon.ammoInMag}/${weapon.magSize}, reserve ${weapon.reserve}`;
  const picks = randomChoices(3); choicesEl.innerHTML='';
  picks.forEach((u,i)=>{ const d=document.createElement('div'); d.className='choice'; d.innerHTML=`<strong>${i+1}) ${u.name}</strong><div class="meta">${u.desc}</div>`; d.onclick=()=>{ u.apply(); upgradeTags.push(u.name); renderTree(); nextRound(); }; choicesEl.appendChild(d); });
  pickUpgrade = (n)=>{ if(picks[n]){ picks[n].apply(); upgradeTags.push(picks[n].name); renderTree(); nextRound(); } };
  renderTree();
}
function nextRound(){ upgradeOverlay.style.display='none'; showingUpgrade=false; round++; player.hp=Math.min(player.maxHp, player.hp+15); spawnRound(); }

// ---------- Start / Pause flow ----------
function hardReset(){
  Object.assign(player,{x:5.5,y:5.5,a:0,fov:settings.fovDeg*Math.PI/180,speed:6.4,rot:2.6,hp:110,maxHp:110,vz:0,z:0,grounded:true});
  Object.assign(weapon,{damage:1,fireRate:3,pierce:0,cooldown:0,critMult:2,magSize:10,ammoInMag:10,reserve:90,reloadTime:1.3,reloading:0});
  round=1; kills=0; enemies.length=0; projectiles.length=0; upgradeTags=[]; regenActive=false; renderTree();
  if(settings.music) startMusic();
  showToast('Good luck!', 1000);
}
function restartRound(){ enemies.forEach(e=>e.alive=false); spawnRound(); showToast('Round restarted',800); }
function toTitle(){
  startOverlay.style.display='flex'; showingStart=true;
  // sync start sliders
  $('#fov_s').value=settings.fovDeg; $('#fov_s_val').textContent=settings.fovDeg+'°';
  $('#sens_s').value=Math.round(settings.sensitivity*100); $('#sens_s_val').textContent=settings.sensitivity.toFixed(2);
  $('#bright_s').value=Math.round(settings.brightness*100); $('#bright_s_val').textContent=settings.brightness.toFixed(2);
  updateMusicLabels(); updateSfxLabels();
}

// ---------- Main loop ----------
function loop(ts){
  const dt=Math.min(0.033,(ts-last)/1000); last=ts;
  if(!showingStart && !showingPause && !showingUpgrade && player.hp>0){ update(dt); }
  render(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ---------- Wire remaining buttons AFTER DOM ready ----------
document.addEventListener('DOMContentLoaded', ()=>{
  updateMusicLabels(); updateSfxLabels();
  // Start menu toggles (after DOM ready too)
  req('#music_s').onclick = ()=>{ settings.music=!settings.music; saveSettings(); updateMusicLabels(); if(settings.music) startMusic(); else stopMusic(); };
  req('#sfx_s').onclick   = ()=>{ settings.sfx=!settings.sfx; saveSettings(); updateSfxLabels(); };
  req('#music_p').onclick = ()=>{ settings.music=!settings.music; saveSettings(); updateMusicLabels(); if(settings.music) startMusic(); else stopMusic(); };
  req('#sfx_p').onclick   = ()=>{ settings.sfx=!settings.sfx; saveSettings(); updateSfxLabels(); };
});

// ---------- Slider helper ----------
function wireSlider(inputSel,labelSel,onChange,fmt,val){
  const i=req(inputSel), l=req(labelSel);
  i.value=val; l.textContent=fmt(val);
  i.addEventListener('input', ()=>{ l.textContent=fmt(i.value); onChange(i.value); });
}
})();
</script>
</body>
</html>
