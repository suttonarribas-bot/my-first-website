<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retro FPS – Level 1 (with Options)</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#eee;font-family:system-ui,Arial}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:8px}
  canvas{width:100vw;max-width:900px;height:60vh;touch-action:none;background:#000}
  .hud{max-width:900px;width:100%;display:flex;flex-wrap:wrap;gap:8px;align-items:center;font-size:14px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{padding:.4rem .7rem;border:1px solid #666;background:#222;color:#eee;border-radius:6px;cursor:pointer}
  .slider{display:flex;gap:6px;align-items:center}
  .slider input{width:140px}
  .spacer{flex:1}
  .zones{position:fixed;inset:0;pointer-events:none}
  .zone{position:absolute;top:0;height:100%;width:50%;pointer-events:auto}
  .left{left:0}
  .right{right:0}
  .toast{position:fixed;top:8px;left:50%;transform:translateX(-50%);background:#222;padding:.4rem .7rem;border:1px solid #555;border-radius:6px;opacity:.9}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="900" height="540"></canvas>

  <div class="hud">
    <div class="row">
      <button id="fireBtn" class="btn">Fire (Space)</button>
      <button id="fsBtn" class="btn">Fullscreen</button>
    </div>
    <div class="spacer"></div>
    <div class="row">
      <div class="slider">
        <label for="fov">FOV</label>
        <input id="fov" type="range" min="40" max="100" value="60">
        <span id="fovVal">60°</span>
      </div>
      <div class="slider">
        <label for="sens">Sensitivity</label>
        <input id="sens" type="range" min="1" max="300" value="120">
        <span id="sensVal">1.20</span>
      </div>
      <div class="slider">
        <label for="bright">Brightness</label>
        <input id="bright" type="range" min="50" max="150" value="100">
        <span id="brightVal">1.00</span>
      </div>
    </div>
    <div style="width:100%;opacity:.8">Controls: WASD move, ←/→ look, Space fire. On phone: left half = move, right half = look/tap to fire.</div>
  </div>
</div>

<div class="zones" aria-hidden="true">
  <div id="zoneLeft" class="zone left"></div>
  <div id="zoneRight" class="zone right"></div>
</div>
<div id="toast" class="toast" style="display:none;"></div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // --- SETTINGS & PERSISTENCE ---
  const settings = {
    fovDeg: getNum('fovDeg', 60),
    sensitivity: getNum('sensitivity', 1.2),    // arrow/touch look multiplier
    brightness: getNum('brightness', 1.0),      // 0.5..1.5
  };
  function getNum(k, d){ const v=localStorage.getItem('rfps_'+k); return v? +v : d; }
  function setNum(k, v){ localStorage.setItem('rfps_'+k, v); }

  // --- WORLD ---
  const MAP_W = 16, MAP_H = 16;
  const map = [
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,2,0,0,0,0,9,1,
    1,0,2,2,0,0,0,0,0,2,0,0,3,0,0,1,
    1,0,0,2,0,0,3,3,0,2,0,0,3,0,0,1,
    1,0,0,2,0,0,0,3,0,2,0,0,0,0,0,1,
    1,0,0,2,0,0,0,3,0,2,0,0,0,0,0,1,
    1,0,0,2,0,0,0,0,0,2,0,0,0,0,0,1,
    1,0,0,0,0,3,3,3,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,2,2,2,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,
    1,0,0,0,0,0,0,3,3,3,0,0,0,2,0,1,
    1,0,0,0,0,0,0,0,0,3,0,0,0,2,0,1,
    1,0,0,0,0,0,0,0,0,3,0,0,0,2,0,1,
    1,0,0,0,0,0,0,0,0,3,0,0,0,2,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  ];
  const WALL_COL = {1:'#a33',2:'#339',3:'#993',9:'#1a3'};

  const enemies = [
    {x: 6.5, y: 3.5, alive: true},
    {x: 11.5,y: 10.5, alive: true}
  ];

  const player = {
    x: 2.5, y: 2.5, a: 0,
    fov: settings.fovDeg * Math.PI/180,
    speed: 3.4,         // a bit faster
    rot: 2.4
  };

  // --- TIMING ---
  let last = performance.now();

  // --- INPUT (KEYBOARD) ---
  const keys = {};
  const keyBlock = new Set(['Space','ArrowLeft','ArrowRight','ArrowUp','ArrowDown','KeyW','KeyA','KeyS','KeyD']);
  addEventListener('keydown', e => {
    keys[e.code]=true;
    if(keyBlock.has(e.code)) e.preventDefault();
    if(e.code==='Space'){ shoot(); }
  }, {passive:false});
  addEventListener('keyup', e => {
    keys[e.code]=false;
    if(keyBlock.has(e.code)) e.preventDefault();
  }, {passive:false});

  // --- TOUCH / POINTER ZONES ---
  const left = document.getElementById('zoneLeft');
  const right = document.getElementById('zoneRight');
  let moveTouch = null, lookTouch = null;
  let moveVec = {x:0,y:0}, lookDelta = 0;
  function norm(v){ const m=Math.hypot(v.x,v.y)||1; return {x:v.x/m,y:v.y/m}; }
  function bindZone(el, cbStart, cbMove, cbEnd){
    el.addEventListener('pointerdown', e => { el.setPointerCapture(e.pointerId); cbStart(e); });
    el.addEventListener('pointermove', cbMove);
    el.addEventListener('pointerup', cbEnd);
    el.addEventListener('pointercancel', cbEnd);
  }
  bindZone(left,
    e => { if(moveTouch) return; moveTouch=e.pointerId; moveVec={x:0,y:0}; },
    e => { if(e.pointerId!==moveTouch) return; const r=left.getBoundingClientRect();
           const cx=r.left+r.width/2, cy=r.top+r.height/2;
           moveVec={x:(e.clientX-cx)/r.width*2, y:(e.clientY-cy)/r.height*2}; },
    e => { if(e.pointerId===moveTouch){ moveTouch=null; moveVec={x:0,y:0}; } }
  );
  bindZone(right,
    e => { if(lookTouch) return; lookTouch=e.pointerId; lookDelta=0; right._lastX=e.clientX; right._tapT=performance.now(); },
    e => { if(e.pointerId!==lookTouch) return;
           const dx=e.clientX-right._lastX; right._lastX=e.clientX; lookDelta+=dx; },
    e => { if(e.pointerId===lookTouch){
             if(performance.now()-right._tapT < 200) shoot();
             lookTouch=null; lookDelta=0;
           } }
  );

  // --- UI: FIRE + FULLSCREEN + SLIDERS ---
  document.getElementById('fireBtn').onclick = () => shoot();

  const fsBtn = document.getElementById('fsBtn');
  fsBtn.onclick = () => {
    const root = document.documentElement;
    if(!document.fullscreenElement){
      (document.body.requestFullscreen || root.requestFullscreen || canvas.requestFullscreen).call(document.body);
    } else {
      document.exitFullscreen && document.exitFullscreen();
    }
  };
  document.addEventListener('fullscreenchange', fitCanvas);

  const fovEl = document.getElementById('fov');
  const fovVal = document.getElementById('fovVal');
  fovEl.value = String(settings.fovDeg);
  fovVal.textContent = settings.fovDeg+'°';
  fovEl.addEventListener('input', () => {
    settings.fovDeg = +fovEl.value;
    player.fov = settings.fovDeg * Math.PI/180;
    fovVal.textContent = settings.fovDeg+'°';
    setNum('fovDeg', settings.fovDeg);
  });

  const sensEl = document.getElementById('sens');
  const sensVal = document.getElementById('sensVal');
  sensEl.value = String(Math.round(settings.sensitivity*100));
  sensVal.textContent = settings.sensitivity.toFixed(2);
  sensEl.addEventListener('input', () => {
    settings.sensitivity = (+sensEl.value)/100;
    sensVal.textContent = settings.sensitivity.toFixed(2);
    setNum('sensitivity', settings.sensitivity);
  });

  const brightEl = document.getElementById('bright');
  const brightVal = document.getElementById('brightVal');
  brightEl.value = String(Math.round(settings.brightness*100));
  brightVal.textContent = settings.brightness.toFixed(2);
  brightEl.addEventListener('input', () => {
    settings.brightness = (+brightEl.value)/100;
    brightVal.textContent = settings.brightness.toFixed(2);
    setNum('brightness', settings.brightness);
  });

  // --- UTIL ---
  function tile(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return 1; return map[(y|0)*MAP_W+(x|0)]; }
  function showToast(msg, ms=1400){
    const t=document.getElementById('toast');
    t.textContent=msg; t.style.display='block';
    clearTimeout(t._to); t._to=setTimeout(()=>t.style.display='none', ms);
  }
  function shade(hex, f){ // multiply RGB by f and clamp
    const c = parseInt(hex.slice(1),16);
    let r=((c>>16)&255)*f|0, g=((c>>8)&255)*f|0, b=(c&255)*f|0;
    r=Math.min(255,Math.max(0,r)); g=Math.min(255,Math.max(0,g)); b=Math.min(255,Math.max(0,b));
    return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
  }

  // --- RENDER STATE ---
  let zbuf = new Float32Array(canvas.width);
  let flashTimer = 0;

  // --- RESIZE / DPR ---
  function fitCanvas(){
    const dpr = Math.min(2, (window.devicePixelRatio||1));
    const cssW = Math.min(window.innerWidth, 900);
    const cssH = Math.floor(cssW*0.6);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.floor(cssW*dpr);
    canvas.height = Math.floor(cssH*dpr);
  }
  fitCanvas();
  addEventListener('resize', fitCanvas);

  // --- RAYCAST ---
  function castRay(ax, ay, ang, max=20){
    const sin=Math.sin(ang), cos=Math.cos(ang);
    let dist = 0, hit=false, side=0, hitTile=0;
    let mapX = Math.floor(ax), mapY = Math.floor(ay);
    const deltaDistX = Math.abs(1 / (cos||1e-6));
    const deltaDistY = Math.abs(1 / (sin||1e-6));
    let stepX = (cos<0)?-1:1, stepY=(sin<0)?-1:1;
    let sideDistX = (cos<0)? (ax-mapX)*deltaDistX : (mapX+1-ax)*deltaDistX;
    let sideDistY = (sin<0)? (ay-mapY)*deltaDistY : (mapY+1-ay)*deltaDistY;

    while(!hit && dist<max){
      if(sideDistX < sideDistY){ sideDistX+=deltaDistX; mapX+=stepX; side=0; }
      else { sideDistY+=deltaDistY; mapY+=stepY; side=1; }
      hitTile = tile(mapX, mapY);
      if(hitTile!==0){
        hit=true;
        dist = (side===0)? (sideDistX-deltaDistX) : (sideDistY-deltaDistY);
      }
    }
    return {dist: dist||max, side, tile:hitTile};
  }

  // --- SHOOT ---
  function shoot(){
    flashTimer = 0.08;
    let closest = {d: 1e9, idx: -1};
    for(let i=0;i<enemies.length;i++){
      const e = enemies[i]; if(!e.alive) continue;
      const dx=e.x-player.x, dy=e.y-player.y;
      const dist=Math.hypot(dx,dy);
      const angTo=Math.atan2(dy,dx);
      let da=((angTo-player.a+Math.PI*3)%(Math.PI*2))-Math.PI;
      if(Math.abs(da) < player.fov*0.06 && dist<8){
        const ray = castRay(player.x, player.y, player.a, 20);
        if(ray.dist+0.05 >= dist){
          if(dist < closest.d){ closest={d:dist, idx:i}; }
        }
      }
    }
    if(closest.idx>=0){
      enemies[closest.idx].alive=false;
      showToast('Enemy down!');
    } else {
      showToast('Miss');
    }
  }

  // --- MAIN LOOP ---
  function loop(ts){
    const dt = Math.min(0.033, (ts-last)/1000); last = ts;

    // Keyboard
    const forward = (keys['KeyW']?1:0) - (keys['KeyS']?1:0);
    const strafe  = (keys['KeyD']?1:0) - (keys['KeyA']?1:0);
    const turn    = (keys['ArrowRight']?1:0) - (keys['ArrowLeft']?1:0);

    // Touch deltas
    const mv = norm(moveVec);
    const look = lookDelta; lookDelta = 0;

    // Rotate
    player.a += (turn*player.rot*dt) + (look * 0.004 * settings.sensitivity);

    // Move (keyboard + touch)
    const sp = player.speed*dt;
    const dirx = Math.cos(player.a), diry = Math.sin(player.a);
    const strx = Math.cos(player.a+Math.PI/2), stry = Math.sin(player.a+Math.PI/2);
    let vx = dirx*(forward*sp) + strx*(strafe*sp) + (mv.x*sp*1.2);
    let vy = diry*(forward*sp) + stry*(strafe*sp) + (mv.y*sp*1.2);

    // Collision
    const pad = 0.2; // small player radius
    const nx = player.x + vx, ny = player.y + vy;
    if(tile(nx + Math.sign(vx)*pad, player.y)===0) player.x = nx;
    if(tile(player.x, ny + Math.sign(vy)*pad)===0) player.y = ny;

    // Exit tile
    const tx = Math.floor(player.x), ty = Math.floor(player.y);
    if(tile(tx,ty)===9 && Math.hypot(player.x-(tx+0.5), player.y-(ty+0.5))<0.7){
      winScreen(); return;
    }

    render(dt);
    requestAnimationFrame(loop);
  }

  function render(dt){
    const W = canvas.width, H = canvas.height;
    const B = settings.brightness;

    // Sky / floor with brightness
    const skyTop = shade('#334', B), skyBot=shade('#112', B);
    const sky = ctx.createLinearGradient(0,0,0,H/2); sky.addColorStop(0,skyTop); sky.addColorStop(1,skyBot);
    ctx.fillStyle = sky; ctx.fillRect(0,0,W,H/2);

    const flTop = shade('#222', B), flBot=shade('#000', B);
    const floor = ctx.createLinearGradient(0,H/2,0,H); floor.addColorStop(0,flTop); floor.addColorStop(1,flBot);
    ctx.fillStyle = floor; ctx.fillRect(0,H/2,W,H/2);

    // Walls
    const cols = W|0;
    zbuf = zbuf.length===cols ? zbuf : new Float32Array(cols);
    for(let x=0;x<cols;x++){
      const cameraX = (2*x/cols - 1);
      const rayAng = player.a + cameraX * player.fov/2 * 2;
      const hit = castRay(player.x, player.y, rayAng, 20);
      const dist = hit.dist * Math.cos(rayAng - player.a);
      zbuf[x] = dist;

      const lineH = Math.min(H, (H / (dist+0.0001)));
      const y0 = (H - lineH)/2;

      let col = WALL_COL[hit.tile] || '#777';
      if(hit.side) col = shade(col, 0.7);
      if(hit.tile===9) col = '#2f5';
      col = shade(col, B);

      ctx.fillStyle = col;
      ctx.fillRect(x, y0, 1, lineH);
    }

    // Sprites
    const visible = [];
    for(const e of enemies){
      if(!e.alive) continue;
      const dx=e.x-player.x, dy=e.y-player.y;
      const dist=Math.hypot(dx,dy);
      const ang=Math.atan2(dy,dx)-player.a;
      let a=((ang+Math.PI*3)%(Math.PI*2))-Math.PI;
      if(Math.abs(a) < player.fov*0.6 && dist>0.2){
        visible.push({e,dist,a});
      }
    }
    visible.sort((a,b)=>b.dist-a.dist);
    for(const v of visible){
      const size = Math.min(H, H/(v.dist));
      const sx = ( (v.a/(player.fov))* (canvas.width/2) ) + canvas.width/2;
      const half = size/2;
      const x0 = (sx-half)|0, x1=(sx+half)|0;
      ctx.fillStyle = shade('#f44', B);
      for(let x=Math.max(0,x0); x<Math.min(canvas.width,x1); x++){
        if(v.dist < zbuf[x]-0.01){
          ctx.fillRect(x, (H/2 - size*0.9), 1, size*0.9*2);
        }
      }
    }

    // Crosshair
    ctx.strokeStyle = shade('#ddd', B);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(W/2-8,H/2); ctx.lineTo(W/2+8,H/2);
    ctx.moveTo(W/2,H/2-8); ctx.lineTo(W/2,H/2+8);
    ctx.stroke();

    // Muzzle flash
    if(flashTimer>0){
      ctx.fillStyle='rgba(255,255,200,0.18)';
      ctx.fillRect(0,0,W,H);
      flashTimer -= dt;
    }

    // Mini-map
    const cell = 6, off=10;
    ctx.fillStyle='#0008';
    ctx.fillRect(off-2,off-2,MAP_W*cell+4,MAP_H*cell+4);
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W;x++){
        const t = map[y*MAP_W+x];
        ctx.fillStyle = t? shade('#666', B) : shade('#111', B);
        if(t===9) ctx.fillStyle=shade('#2f5', B);
        ctx.fillRect(off+x*cell, off+y*cell, cell-1, cell-1);
      }
    }
    for(const e of enemies){
      ctx.fillStyle = e.alive ? shade('#f44', B) : shade('#555', B);
      ctx.fillRect(off+e.x*cell-1, off+e.y*cell-1, 3,3);
    }
    ctx.fillStyle=shade('#4cf', B);
    ctx.beginPath();
    const px = off+player.x*cell, py=off+player.y*cell;
    ctx.arc(px,py,2,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle=shade('#4cf', B); ctx.beginPath();
    ctx.moveTo(px,py);
    ctx.lineTo(px+Math.cos(player.a)*8, py+Math.sin(player.a)*8);
    ctx.stroke();
  }

  function winScreen(){
    const W=canvas.width,H=canvas.height;
    ctx.fillStyle='#020'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#2f5'; ctx.textAlign='center';
    ctx.font = Math.floor(H*0.08)+'px system-ui,Arial';
    ctx.fillText('LEVEL COMPLETE', W/2, H/2);
    ctx.font = Math.floor(H*0.035)+'px system-ui,Arial';
    ctx.fillText('You reached the exit!', W/2, H/2+50);
  }

  // Startup
  showToast('Find the green exit. Space/tap to shoot.');
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
