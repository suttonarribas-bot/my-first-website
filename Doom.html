<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retro Arena – Rounds & Upgrades</title>
<style>
  html,body{margin:0;height:100%;background:#0e0e0e;color:#eee;font-family:system-ui,Arial}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:8px}
  canvas{width:100vw;max-width:960px;height:60vh;touch-action:none;background:#000}
  .hud{max-width:960px;width:100%;display:flex;flex-wrap:wrap;gap:10px;align-items:center;font-size:14px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{padding:.5rem .8rem;border:1px solid #666;background:#222;color:#eee;border-radius:8px;cursor:pointer}
  .slider{display:flex;gap:8px;align-items:center}
  .slider input{width:170px;height:30px}
  .value{min-width:44px;text-align:right}
  .spacer{flex:1}
  /* Touch zones */
  .zones{position:fixed;inset:0;pointer-events:none}
  .zone{position:absolute;top:0;height:100%;width:50%;pointer-events:auto}
  .left{left:0}
  .right{right:0}
  /* Overlays */
  .toast{position:fixed;top:8px;left:50%;transform:translateX(-50%);background:#222;padding:.5rem .8rem;border:1px solid #555;border-radius:8px;opacity:.95}
  .overlay{
    position:fixed;inset:0;background:rgba(0,0,0,.7);
    display:none;align-items:center;justify-content:center;padding:16px
  }
  .panel{
    background:#161616;border:1px solid #444;border-radius:12px;padding:16px;max-width:720px;width:95%;
    box-shadow:0 8px 32px rgba(0,0,0,.5)
  }
  .panel h2{margin:0 0 8px 0}
  .choices{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px;margin-top:10px}
  .choice{border:1px solid #555;background:#1e1e1e;border-radius:10px;padding:12px;cursor:pointer}
  .choice:hover{background:#262626}
  .meta{opacity:.85;font-size:13px}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="960" height="576" aria-label="Retro Arena view"></canvas>

  <div class="hud" role="group" aria-label="Controls">
    <div class="row">
      <button id="fireBtn" class="btn">Fire (Space)</button>
      <button id="fsBtn" class="btn">Fullscreen</button>
    </div>
    <div class="spacer"></div>
    <div class="row" role="group" aria-label="Settings">
      <div class="slider">
        <label for="fov">FOV</label>
        <input id="fov" type="range" min="45" max="105" step="1" value="70">
        <span id="fovVal" class="value">70°</span>
      </div>
      <div class="slider">
        <label for="sens">Sensitivity</label>
        <input id="sens" type="range" min="60" max="300" step="1" value="140">
        <span id="sensVal" class="value">1.40</span>
      </div>
      <div class="slider">
        <label for="bright">Brightness</label>
        <input id="bright" type="range" min="70" max="160" step="1" value="125">
        <span id="brightVal" class="value">1.25</span>
      </div>
    </div>
    <div style="width:100%;opacity:.85">WASD move, ←/→ look, Space fire. Phone: drag left to move, drag right to look, tap right to fire.</div>
  </div>
</div>

<!-- Touch zones -->
<div class="zones" aria-hidden="true">
  <div id="zoneLeft" class="zone left"></div>
  <div id="zoneRight" class="zone right"></div>
</div>

<!-- Intermission / upgrade overlay -->
<div id="overlay" class="overlay" role="dialog" aria-modal="true">
  <div class="panel">
    <h2 id="overlayTitle">Round Complete</h2>
    <div class="meta" id="overlayMeta"></div>
    <div style="margin-top:10px">Pick one upgrade:</div>
    <div class="choices" id="choices"></div>
    <div class="meta" style="margin-top:10px">Tip: You can press keys 1 / 2 / 3 to pick fast.</div>
  </div>
</div>

<div id="toast" class="toast" style="display:none;"></div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // ---------------- Settings / Persistence ----------------
  const settings = {
    fovDeg: getNum('arena_fov', 70),
    sensitivity: getNum('arena_sens', 1.4),
    brightness: getNum('arena_bright', 1.25),
  };
  function getNum(k, d){ const v=localStorage.getItem(k); return v? +v : d; }
  function setNum(k, v){ localStorage.setItem(k, v); }

  // ---------------- World (open arena with border walls) ----------------
  const MAP_W = 24, MAP_H = 24;
  // Build outer walls with a few pillars to dodge around
  const map = new Array(MAP_W*MAP_H).fill(0);
  function idx(x,y){ return y*MAP_W+x; }
  for(let x=0;x<MAP_W;x++){ map[idx(x,0)]=1; map[idx(x,MAP_H-1)]=1; }
  for(let y=0;y<MAP_H;y++){ map[idx(0,y)]=1; map[idx(MAP_W-1,y)]=1; }
  // Pillars
  const pillars = [[6,6],[6,17],[12,12],[17,6],[17,17]];
  for(const [px,py] of pillars){
    for(let dy=-1;dy<=1;dy++)
      for(let dx=-1;dx<=1;dx++)
        map[idx(px+dx,py+dy)] = 2;
  }
  const WALL_COL = {1:'#555',2:'#884'}; // simple palette

  // ---------------- Player & Weapon ----------------
  const player = {
    x: 4.5, y: 4.5, a: 0,
    fov: settings.fovDeg * Math.PI/180,
    speed: 6.2,
    rot: 2.6,
    hp: 100, maxHp: 100,
  };

  const weapon = {
    damage: 1,        // base damage per hit
    fireRate: 2.8,    // shots/sec
    pierce: 0,        // how many extra targets the ray can pass
    cooldown: 0,      // sec left until next shot
  };

  // ---------------- Rounds & Spawning ----------------
  let round = 1;
  let kills = 0;
  let enemies = [];

  function spawnRound(n){
    enemies.length = 0;
    const count = Math.min(6 + round*2, 60);
    for(let i=0;i<count;i++){
      const pos = randSpawn();
      enemies.push({
        x: pos.x, y: pos.y, alive: true,
        hp: 1 + Math.floor((round-1)/2),
        speed: 1.1 + Math.min(1.2, (round-1)*0.06),
        touchDmg: 7 + Math.floor(round*0.6),
      });
    }
  }
  function randSpawn(){
    // spawn away from player and not in walls
    for(let t=0;t<200;t++){
      const x = 2 + Math.random()*(MAP_W-4);
      const y = 2 + Math.random()*(MAP_H-4);
      if(tile(x,y)!==0) continue;
      if(Math.hypot(x-player.x,y-player.y) < 6) continue;
      return {x,y};
    }
    return {x: MAP_W-3, y: MAP_H-3};
  }

  // ---------------- Timing / Input ----------------
  let last = performance.now();
  const keys = {};
  const keyBlock = new Set(['Space','ArrowLeft','ArrowRight','ArrowUp','ArrowDown','KeyW','KeyA','KeyS','KeyD','Digit1','Digit2','Digit3']);
  addEventListener('keydown', e => {
    keys[e.code]=true;
    if(keyBlock.has(e.code)) e.preventDefault();
    if(e.code==='Space') shoot();
    if(showingOverlay){
      if(e.code==='Digit1') pickUpgrade(0);
      if(e.code==='Digit2') pickUpgrade(1);
      if(e.code==='Digit3') pickUpgrade(2);
    }
  }, {passive:false});
  addEventListener('keyup', e => {
    keys[e.code]=false;
    if(keyBlock.has(e.code)) e.preventDefault();
  }, {passive:false});

  // Touch controls
  const left = document.getElementById('zoneLeft');
  const right = document.getElementById('zoneRight');
  let moveTouch = null, lookTouch = null;
  let moveVec = {x:0,y:0}, lookDelta = 0;
  function norm(v){ const m=Math.hypot(v.x,v.y)||1; return {x:v.x/m,y:v.y/m}; }
  function bindZone(el, cbStart, cbMove, cbEnd){
    el.addEventListener('pointerdown', e => { el.setPointerCapture(e.pointerId); cbStart(e); });
    el.addEventListener('pointermove', cbMove);
    el.addEventListener('pointerup', cbEnd);
    el.addEventListener('pointercancel', cbEnd);
  }
  bindZone(left,
    e => { if(moveTouch) return; moveTouch=e.pointerId; moveVec={x:0,y:0}; },
    e => { if(e.pointerId!==moveTouch) return; const r=left.getBoundingClientRect();
           const cx=r.left+r.width/2, cy=r.top+r.height/2;
           moveVec={x:(e.clientX-cx)/r.width*2, y:(e.clientY-cy)/r.height*2}; },
    e => { if(e.pointerId===moveTouch){ moveTouch=null; moveVec={x:0,y:0}; } }
  );
  bindZone(right,
    e => { if(lookTouch) return; lookTouch=e.pointerId; lookDelta=0; right._lastX=e.clientX; right._tapT=performance.now(); },
    e => { if(e.pointerId!==lookTouch) return;
           const dx=e.clientX-right._lastX; right._lastX=e.clientX; lookDelta+=dx; },
    e => { if(e.pointerId===lookTouch){
             if(performance.now()-right._tapT < 200) shoot();
             lookTouch=null; lookDelta=0;
           } }
  );

  document.getElementById('fireBtn').onclick = () => shoot();
  const fsBtn = document.getElementById('fsBtn');
  fsBtn.onclick = () => {
    if(!document.fullscreenElement){
      (document.body.requestFullscreen||document.documentElement.requestFullscreen||canvas.requestFullscreen).call(document.body);
    } else document.exitFullscreen && document.exitFullscreen();
  };
  document.addEventListener('fullscreenchange', fitCanvas);

  // Sliders
  const fovEl = document.getElementById('fov'), fovVal = document.getElementById('fovVal');
  const sensEl = document.getElementById('sens'), sensVal = document.getElementById('sensVal');
  const brightEl = document.getElementById('bright'), brightVal = document.getElementById('brightVal');
  fovEl.value = settings.fovDeg; fovVal.textContent = settings.fovDeg+'°';
  sensEl.value = Math.round(settings.sensitivity*100); sensVal.textContent=settings.sensitivity.toFixed(2);
  brightEl.value = Math.round(settings.brightness*100); brightVal.textContent=settings.brightness.toFixed(2);
  fovEl.addEventListener('input', ()=>{ settings.fovDeg=+fovEl.value; player.fov=settings.fovDeg*Math.PI/180; fovVal.textContent=settings.fovDeg+'°'; setNum('arena_fov',settings.fovDeg); });
  sensEl.addEventListener('input', ()=>{ settings.sensitivity=(+sensEl.value)/100; sensVal.textContent=settings.sensitivity.toFixed(2); setNum('arena_sens',settings.sensitivity); });
  brightEl.addEventListener('input', ()=>{ settings.brightness=(+brightEl.value)/100; brightVal.textContent=settings.brightness.toFixed(2); setNum('arena_bright',settings.brightness); });

  // ---------------- Utilities ----------------
  function tile(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return 1; return map[(y|0)*MAP_W+(x|0)]; }
  function shade(hex, f){
    const c = parseInt(hex.slice(1),16);
    let r=((c>>16)&255)*f|0, g=((c>>8)&255)*f|0, b=(c&255)*f|0;
    r=Math.min(255,Math.max(0,r)); g=Math.min(255,Math.max(0,g)); b=Math.min(255,Math.max(0,b));
    return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
  }
  function showToast(msg, ms=1200){
    const t=document.getElementById('toast');
    t.textContent=msg; t.style.display='block';
    clearTimeout(t._to); t._to=setTimeout(()=>t.style.display='none', ms);
  }

  // ---------------- Raycast ----------------
  function castRay(ax, ay, ang, max=40){
    const sin=Math.sin(ang), cos=Math.cos(ang);
    let dist = 0, hit=false, side=0, hitTile=0;
    let mapX = Math.floor(ax), mapY = Math.floor(ay);
    const deltaDistX = Math.abs(1 / (cos||1e-6));
    const deltaDistY = Math.abs(1 / (sin||1e-6));
    let stepX = (cos<0)?-1:1, stepY=(sin<0)?-1:1;
    let sideDistX = (cos<0)? (ax-mapX)*deltaDistX : (mapX+1-ax)*deltaDistX;
    let sideDistY = (sin<0)? (ay-mapY)*deltaDistY : (mapY+1-ay)*deltaDistY;

    while(!hit && dist<max){
      if(sideDistX < sideDistY){ sideDistX+=deltaDistX; mapX+=stepX; side=0; }
      else { sideDistY+=deltaDistY; mapY+=stepY; side=1; }
      hitTile = tile(mapX, mapY);
      if(hitTile!==0){
        hit=true;
        dist = (side===0)? (sideDistX-deltaDistX) : (sideDistY-deltaDistY);
      }
    }
    return {dist: dist||max, side, tile:hitTile};
  }

  // ---------------- Combat ----------------
  let flashTimer = 0;
  function shoot(){
    if(showingOverlay) return;
    if(weapon.cooldown > 0) return;
    flashTimer = 0.06;
    weapon.cooldown = 1 / weapon.fireRate;

    // hitscan from crosshair, collect enemies near ray center, sort by distance
    const candidates = [];
    for(let i=0;i<enemies.length;i++){
      const e=enemies[i]; if(!e.alive) continue;
      const dx=e.x-player.x, dy=e.y-player.y;
      const dist=Math.hypot(dx,dy);
      const angTo=Math.atan2(dy,dx);
      let da=((angTo-player.a+Math.PI*3)%(Math.PI*2))-Math.PI;
      if(Math.abs(da) < player.fov*0.05 && dist<20){
        // wall occlusion
        const ray = castRay(player.x, player.y, player.a, 40);
        if(ray.dist+0.05 >= dist){ // not behind wall
          candidates.push({i,dist});
        }
      }
    }
    candidates.sort((a,b)=>a.dist-b.dist);

    let pierceLeft = weapon.pierce;
    let hitAny = false;
    for(const c of candidates){
      const e = enemies[c.i];
      if(!e.alive) continue;
      e.hp -= weapon.damage;
      hitAny = true;
      if(e.hp<=0){ e.alive=false; kills++; }
      if(pierceLeft<=0) break;
      pierceLeft--;
    }
    showToast(hitAny ? 'Hit!' : 'Miss', 500);
  }

  // ---------------- AI & Collision ----------------
  function tryMove(obj, vx, vy){
    const pad = 0.2;
    const nx = obj.x + vx, ny = obj.y + vy;
    if(tile(nx + Math.sign(vx)*pad, obj.y)===0) obj.x = nx;
    if(tile(obj.x, ny + Math.sign(vy)*pad)===0) obj.y = ny;
  }

  // ---------------- Overlay: upgrades ----------------
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayMeta = document.getElementById('overlayMeta');
  const choicesEl = document.getElementById('choices');
  let showingOverlay = false;

  const upgradePool = [
    {name:'+Damage', desc:'+1 weapon damage', apply:()=>weapon.damage+=1},
    {name:'+Fire Rate', desc:'+20% fire rate', apply:()=>weapon.fireRate*=1.2},
    {name:'Pierce +1', desc:'Bullets pierce one extra target', apply:()=>weapon.pierce+=1},
    {name:'Dash Boots', desc:'+12% move speed', apply:()=>player.speed*=1.12},
    {name:'Thicker Skin', desc:'+20 max HP & heal 20', apply:()=>{player.maxHp+=20; player.hp=Math.min(player.maxHp, player.hp+20);} },
  ];

  function randomChoices(n=3){
    const pool = [...upgradePool];
    const picks=[];
    for(let i=0;i<n && pool.length;i++){
      const k = Math.floor(Math.random()*pool.length);
      picks.push(pool.splice(k,1)[0]);
    }
    return picks;
  }

  function showUpgradeOverlay(){
    showingOverlay = true;
    overlay.style.display='flex';
    overlayTitle.textContent = `Round ${round} cleared`;
    overlayMeta.textContent = `Kills: ${kills}  |  Weapon: dmg ${weapon.damage}, ROF ${weapon.fireRate.toFixed(2)}/s, pierce ${weapon.pierce}`;
    choicesEl.innerHTML = '';
    const picks = randomChoices(3);
    picks.forEach((u,idx)=>{
      const d = document.createElement('div');
      d.className='choice';
      d.innerHTML = `<strong>${idx+1}) ${u.name}</strong><div class="meta">${u.desc}</div>`;
      d.onclick = () => { u.apply(); hideOverlayAndNextRound(); };
      choicesEl.appendChild(d);
    });
    // keyboard helpers
    pickUpgrade = (n)=>{ if(picks[n]){ picks[n].apply(); hideOverlayAndNextRound(); } };
  }

  let pickUpgrade = ()=>{};
  function hideOverlayAndNextRound(){
    overlay.style.display='none';
    showingOverlay = false;
    round++;
    spawnRound(round);
  }

  // ---------------- DPR / Resize ----------------
  let zbuf = new Float32Array(canvas.width);
  function fitCanvas(){
    const dpr = Math.min(2, (window.devicePixelRatio||1));
    const cssW = Math.min(window.innerWidth, 960);
    const cssH = Math.floor(cssW*0.6);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.floor(cssW*dpr);
    canvas.height = Math.floor(cssH*dpr);
  }
  fitCanvas();
  addEventListener('resize', fitCanvas);

  // ---------------- Main Loop ----------------
  function loop(ts){
    const dt = Math.min(0.033, (ts-last)/1000); last = ts;

    // Cooldowns
    if(weapon.cooldown>0) weapon.cooldown = Math.max(0, weapon.cooldown - dt);

    // If overlay is up, we only render the paused scene
    if(!showingOverlay){
      // Input
      const forward = (keys['KeyW']?1:0) - (keys['KeyS']?1:0);
      const strafe  = (keys['KeyD']?1:0) - (keys['KeyA']?1:0);
      const turn    = (keys['ArrowRight']?1:0) - (keys['ArrowLeft']?1:0);

      const mv = norm(moveVec);
      const look = lookDelta; lookDelta = 0;

      // Rotate
      player.a += (turn*player.rot*dt) + (look * 0.004 * settings.sensitivity);

      // Move
      const sp = player.speed*dt;
      const dirx = Math.cos(player.a), diry = Math.sin(player.a);
      const strx = Math.cos(player.a+Math.PI/2), stry = Math.sin(player.a+Math.PI/2);
      let vx = dirx*(forward*sp) + strx*(strafe*sp) + (mv.x*sp*1.2);
      let vy = diry*(forward*sp) + stry*(strafe*sp) + (mv.y*sp*1.2);
      tryMove(player, vx, vy);

      // Enemies: chase
      for(const e of enemies){
        if(!e.alive) continue;
        const dx = player.x - e.x, dy = player.y - e.y;
        const d = Math.hypot(dx,dy) || 1;
        const spd = e.speed*dt;
        tryMove(e, (dx/d)*spd, (dy/d)*spd);
        // contact damage
        if(d < 0.6){
          player.hp -= e.touchDmg*dt; // DPS on contact
          if(player.hp<=0) player.hp=0;
        }
      }

      // Check round clear
      if(enemies.every(e=>!e.alive)){
        showUpgradeOverlay();
      }
    }

    render(dt);
    requestAnimationFrame(loop);
  }

  function render(dt){
    const W = canvas.width, H = canvas.height;
    const B = settings.brightness;

    // Sky & floor
    const sky = ctx.createLinearGradient(0,0,0,H/2);
    sky.addColorStop(0,shade('#1a2240',B)); sky.addColorStop(1,shade('#0a0f1a',B));
    ctx.fillStyle=sky; ctx.fillRect(0,0,W,H/2);
    const floor = ctx.createLinearGradient(0,H/2,0,H);
    floor.addColorStop(0,shade('#242424',B)); floor.addColorStop(1,shade('#0a0a0a',B));
    ctx.fillStyle=floor; ctx.fillRect(0,H/2,W,H/2);

    // Walls
    const cols = W|0;
    if(zbuf.length!==cols) zbuf = new Float32Array(cols);
    for(let x=0;x<cols;x++){
      const cameraX = (2*x/cols - 1);
      const rayAng = player.a + cameraX * player.fov/2 * 2;
      const hit = castRay(player.x, player.y, rayAng, 40);
      const dist = hit.dist * Math.cos(rayAng - player.a);
      zbuf[x] = dist;

      const lineH = Math.min(H, (H / (dist+0.0001)));
      const y0 = (H - lineH)/2;

      let col = WALL_COL[hit.tile] || '#777';
      if(hit.side) col = shade(col, 0.7);
      col = shade(col, B);

      ctx.fillStyle = col;
      ctx.fillRect(x, y0, 1, lineH);
    }

    // Enemies (billboards)
    const vis=[];
    for(const e of enemies){
      if(!e.alive) continue;
      const dx=e.x-player.x, dy=e.y-player.y;
      const dist=Math.hypot(dx,dy);
      const ang=Math.atan2(dy,dx)-player.a;
      let a=((ang+Math.PI*3)%(Math.PI*2))-Math.PI;
      if(Math.abs(a) < player.fov*0.65 && dist>0.2) vis.push({e,dist,a});
    }
    vis.sort((a,b)=>b.dist-a.dist);
    for(const v of vis){
      const size = Math.min(H, H/(v.dist));
      const sx = ( (v.a/(player.fov))* (W/2) ) + W/2;
      const half = size/2;
      const x0 = (sx-half)|0, x1=(sx+half)|0;
      ctx.fillStyle = shade('#f44', B);
      for(let x=Math.max(0,x0); x<Math.min(W,x1); x++){
        if(v.dist < zbuf[x]-0.01){
          // body
          ctx.fillRect(x, (H/2 - size*0.9), 1, size*0.9*2);
        }
      }
      // tiny HP bar
      const hpRatio = Math.max(0, v.e.hp) / (1 + Math.floor((round-1)/2));
      const barW = Math.max(10, size*0.3);
      ctx.fillStyle='#000';
      ctx.fillRect(sx-barW/2, H/2 - size*0.95 - 8, barW, 6);
      ctx.fillStyle='#2f5';
      ctx.fillRect(sx-barW/2, H/2 - size*0.95 - 8, barW*hpRatio, 6);
    }

    // Crosshair
    ctx.strokeStyle = shade('#ddd', B);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(W/2-8,H/2); ctx.lineTo(W/2+8,H/2);
    ctx.moveTo(W/2,H/2-8); ctx.lineTo(W/2,H/2+8);
    ctx.stroke();

    // Muzzle flash
    if(flashTimer>0){
      ctx.fillStyle='rgba(255,255,200,0.15)';
      ctx.fillRect(0,0,W,H);
      flashTimer -= dt;
    }

    // Mini-map (top-left)
    const cell = 6, off=10;
    ctx.fillStyle='#0008';
    ctx.fillRect(off-2,off-2,MAP_W*cell+4,MAP_H*cell+4);
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W;x++){
        const t = map[idx(x,y)];
        ctx.fillStyle = t? shade('#666', B) : shade('#141414', B);
        ctx.fillRect(off+x*cell, off+y*cell, cell-1, cell-1);
      }
    }
    // player and enemies
    ctx.fillStyle=shade('#4cf', B);
    const px = off+player.x*cell, py=off+player.y*cell;
    ctx.beginPath(); ctx.arc(px,py,2,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle=shade('#4cf', B); ctx.beginPath();
    ctx.moveTo(px,py); ctx.lineTo(px+Math.cos(player.a)*8, py+Math.sin(player.a)*8); ctx.stroke();

    for(const e of enemies){
      ctx.fillStyle = e.alive ? shade('#f44', B) : shade('#555', B);
      ctx.fillRect(off+e.x*cell-1, off+e.y*cell-1, 3,3);
    }

    // HUD: round (top-right), HP & Kills (bottom-left)
    ctx.fillStyle='#0009';
    const boxW=150, boxH=36, pad=10;
    ctx.fillRect(W-boxW-pad, pad, boxW, boxH);
    ctx.fillStyle='#fff';
    ctx.font = 'bold 16px system-ui,Arial';
    ctx.textAlign='left'; ctx.textBaseline='top';
    ctx.fillText(`Round: ${round}`, W-boxW+8-pad, pad+6);

    // HP & kills
    ctx.fillStyle='#0009';
    const bw=220,bh=48;
    ctx.fillRect(pad,H-bh-pad,bw,bh);
    ctx.fillStyle='#fff';
    ctx.fillText(`HP: ${Math.ceil(player.hp)}/${player.maxHp}`, pad+8, H-bh+6-pad);
    ctx.fillText(`Kills: ${kills}`, pad+8, H-bh+24-pad);

    if(player.hp<=0){
      ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#f55'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font = 'bold 42px system-ui,Arial'; ctx.fillText('YOU DIED', W/2, H/2-10);
      ctx.font = '18px system-ui,Arial'; ctx.fillStyle='#fff';
      ctx.fillText(`Rounds survived: ${round-1}  •  Kills: ${kills}`, W/2, H/2+28);
    }
  }

  // ---------------- Start ----------------
  function startGame(){
    spawnRound(round);
    showToast('Clear enemies. Upgrade between rounds.', 1600);
    requestAnimationFrame(loop);
  }
  startGame();
})();
</script>
</body>
</html>
